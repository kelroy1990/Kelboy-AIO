   1               		.file	"BootloaderDFU.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.DiscardFillerBytes,"ax",@progbits
  13               	DiscardFillerBytes:
  14               	.LFB78:
  15               		.file 1 "BootloaderDFU.c"
   1:BootloaderDFU.c **** /*
   2:BootloaderDFU.c ****              LUFA Library
   3:BootloaderDFU.c ****      Copyright (C) Dean Camera, 2010.
   4:BootloaderDFU.c **** 
   5:BootloaderDFU.c ****   dean [at] fourwalledcubicle [dot] com
   6:BootloaderDFU.c ****       www.fourwalledcubicle.com
   7:BootloaderDFU.c **** */
   8:BootloaderDFU.c **** 
   9:BootloaderDFU.c **** /*
  10:BootloaderDFU.c ****   Copyright 2010  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:BootloaderDFU.c **** 
  12:BootloaderDFU.c ****   Permission to use, copy, modify, distribute, and sell this
  13:BootloaderDFU.c ****   software and its documentation for any purpose is hereby granted
  14:BootloaderDFU.c ****   without fee, provided that the above copyright notice appear in
  15:BootloaderDFU.c ****   all copies and that both that the copyright notice and this
  16:BootloaderDFU.c ****   permission notice and warranty disclaimer appear in supporting
  17:BootloaderDFU.c ****   documentation, and that the name of the author not be used in
  18:BootloaderDFU.c ****   advertising or publicity pertaining to distribution of the
  19:BootloaderDFU.c ****   software without specific, written prior permission.
  20:BootloaderDFU.c **** 
  21:BootloaderDFU.c ****   The author disclaim all warranties with regard to this
  22:BootloaderDFU.c ****   software, including all implied warranties of merchantability
  23:BootloaderDFU.c ****   and fitness.  In no event shall the author be liable for any
  24:BootloaderDFU.c ****   special, indirect or consequential damages or any damages
  25:BootloaderDFU.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:BootloaderDFU.c ****   in an action of contract, negligence or other tortious action,
  27:BootloaderDFU.c ****   arising out of or in connection with the use or performance of
  28:BootloaderDFU.c ****   this software.
  29:BootloaderDFU.c **** */
  30:BootloaderDFU.c **** 
  31:BootloaderDFU.c **** /** \file
  32:BootloaderDFU.c ****  *
  33:BootloaderDFU.c ****  *  Main source file for the DFU class bootloader. This file contains the complete bootloader logic
  34:BootloaderDFU.c ****  */
  35:BootloaderDFU.c **** 
  36:BootloaderDFU.c **** #define  INCLUDE_FROM_BOOTLOADER_C
  37:BootloaderDFU.c **** #include "BootloaderDFU.h"
  38:BootloaderDFU.c **** 
  39:BootloaderDFU.c **** /** Flag to indicate if the bootloader is currently running in secure mode, disallowing memory oper
  40:BootloaderDFU.c ****  *  other than erase. This is initially set to the value set by SECURE_MODE, and cleared by the boo
  41:BootloaderDFU.c ****  *  once a memory erase has completed.
  42:BootloaderDFU.c ****  */
  43:BootloaderDFU.c **** bool IsSecure      = SECURE_MODE;
  44:BootloaderDFU.c **** 
  45:BootloaderDFU.c **** /** Flag to indicate if the bootloader should be running, or should exit and allow the application 
  46:BootloaderDFU.c ****  *  via a soft reset. When cleared, the bootloader will abort, the USB interface will shut down and
  47:BootloaderDFU.c ****  *  jumped to via an indirect jump to location 0x0000 (or other location specified by the host).
  48:BootloaderDFU.c ****  */
  49:BootloaderDFU.c **** bool RunBootloader = true;
  50:BootloaderDFU.c **** 
  51:BootloaderDFU.c **** /** Flag to indicate if the bootloader is waiting to exit. When the host requests the bootloader to
  52:BootloaderDFU.c ****  *  jump to the application address it specifies, it sends two sequential commands which must be pr
  53:BootloaderDFU.c ****  *  acknowledged. Upon reception of the first the RunBootloader flag is cleared and the WaitForExit
  54:BootloaderDFU.c ****  *  causing the bootloader to wait for the final exit command before shutting down.
  55:BootloaderDFU.c ****  */
  56:BootloaderDFU.c **** bool WaitForExit = false;
  57:BootloaderDFU.c **** 
  58:BootloaderDFU.c **** /** Current DFU state machine state, one of the values in the DFU_State_t enum. */
  59:BootloaderDFU.c **** uint8_t DFU_State = dfuIDLE;
  60:BootloaderDFU.c **** 
  61:BootloaderDFU.c **** /** Status code of the last executed DFU command. This is set to one of the values in the DFU_Statu
  62:BootloaderDFU.c ****  *  each operation, and returned to the host when a Get Status DFU request is issued.
  63:BootloaderDFU.c ****  */
  64:BootloaderDFU.c **** uint8_t DFU_Status = OK;
  65:BootloaderDFU.c **** 
  66:BootloaderDFU.c **** /** Data containing the DFU command sent from the host. */
  67:BootloaderDFU.c **** DFU_Command_t SentCommand;
  68:BootloaderDFU.c **** 
  69:BootloaderDFU.c **** /** Response to the last issued Read Data DFU command. Unlike other DFU commands, the read command
  70:BootloaderDFU.c ****  *  requires a single byte response from the bootloader containing the read data when the next DFU_
  71:BootloaderDFU.c ****  *  is issued by the host.
  72:BootloaderDFU.c ****  */
  73:BootloaderDFU.c **** uint8_t ResponseByte;
  74:BootloaderDFU.c **** 
  75:BootloaderDFU.c **** /** Pointer to the start of the user application. By default this is 0x0000 (the reset vector), how
  76:BootloaderDFU.c ****  *  may specify an alternate address when issuing the application soft-start command.
  77:BootloaderDFU.c ****  */
  78:BootloaderDFU.c **** AppPtr_t AppStartPtr = (AppPtr_t)0x0000;
  79:BootloaderDFU.c **** 
  80:BootloaderDFU.c **** /** 64-bit flash page number. This is concatenated with the current 16-bit address on USB AVRs cont
  81:BootloaderDFU.c ****  *  64KB of flash memory.
  82:BootloaderDFU.c ****  */
  83:BootloaderDFU.c **** uint8_t Flash64KBPage = 0;
  84:BootloaderDFU.c **** 
  85:BootloaderDFU.c **** /** Memory start address, indicating the current address in the memory being addressed (either FLAS
  86:BootloaderDFU.c ****  *  depending on the issued command from the host).
  87:BootloaderDFU.c ****  */
  88:BootloaderDFU.c **** uint16_t StartAddr = 0x0000;
  89:BootloaderDFU.c **** 
  90:BootloaderDFU.c **** /** Memory end address, indicating the end address to read to/write from in the memory being addres
  91:BootloaderDFU.c ****  *  of EEPROM depending on the issued command from the host).
  92:BootloaderDFU.c ****  */
  93:BootloaderDFU.c **** uint16_t EndAddr = 0x0000;
  94:BootloaderDFU.c **** 
  95:BootloaderDFU.c **** 
  96:BootloaderDFU.c **** /** Main program entry point. This routine configures the hardware required by the bootloader, then
  97:BootloaderDFU.c ****  *  runs the bootloader processing routine until instructed to soft-exit, or hard-reset via the wat
  98:BootloaderDFU.c ****  *  the loaded application code.
  99:BootloaderDFU.c ****  */
 100:BootloaderDFU.c **** int main(void)
 101:BootloaderDFU.c **** {
 102:BootloaderDFU.c **** 	/* Configure hardware required by the bootloader */
 103:BootloaderDFU.c **** 	SetupHardware();
 104:BootloaderDFU.c **** 
 105:BootloaderDFU.c **** 	/* Enable global interrupts so that the USB stack can function */
 106:BootloaderDFU.c **** 	sei();
 107:BootloaderDFU.c **** 
 108:BootloaderDFU.c **** 	/* Run the USB management task while the bootloader is supposed to be running */
 109:BootloaderDFU.c **** 	while (RunBootloader || WaitForExit)
 110:BootloaderDFU.c **** 	  USB_USBTask();
 111:BootloaderDFU.c **** 
 112:BootloaderDFU.c **** 	/* Reset configured hardware back to their original states for the user application */
 113:BootloaderDFU.c **** 	ResetHardware();
 114:BootloaderDFU.c **** 
 115:BootloaderDFU.c **** 	/* Start the user application */
 116:BootloaderDFU.c **** 	AppStartPtr();
 117:BootloaderDFU.c **** }
 118:BootloaderDFU.c **** 
 119:BootloaderDFU.c **** /** Configures all hardware required for the bootloader. */
 120:BootloaderDFU.c **** void SetupHardware(void)
 121:BootloaderDFU.c **** {
 122:BootloaderDFU.c **** 	/* Disable watchdog if enabled by bootloader/fuses */
 123:BootloaderDFU.c **** 	MCUSR &= ~(1 << WDRF);
 124:BootloaderDFU.c **** 	wdt_disable();
 125:BootloaderDFU.c **** 
 126:BootloaderDFU.c **** 	/* Disable clock division */
 127:BootloaderDFU.c **** 	clock_prescale_set(clock_div_1);
 128:BootloaderDFU.c **** 
 129:BootloaderDFU.c **** 	/* Relocate the interrupt vector table to the bootloader section */
 130:BootloaderDFU.c **** 	MCUCR = (1 << IVCE);
 131:BootloaderDFU.c **** 	MCUCR = (1 << IVSEL);
 132:BootloaderDFU.c **** 
 133:BootloaderDFU.c **** 	/* Initialize the USB subsystem */
 134:BootloaderDFU.c **** 	USB_Init();
 135:BootloaderDFU.c **** }
 136:BootloaderDFU.c **** 
 137:BootloaderDFU.c **** /** Resets all configured hardware required for the bootloader back to their original states. */
 138:BootloaderDFU.c **** void ResetHardware(void)
 139:BootloaderDFU.c **** {
 140:BootloaderDFU.c **** 	/* Shut down the USB subsystem */
 141:BootloaderDFU.c **** 	USB_ShutDown();
 142:BootloaderDFU.c **** 
 143:BootloaderDFU.c **** 	/* Relocate the interrupt vector table back to the application section */
 144:BootloaderDFU.c **** 	MCUCR = (1 << IVCE);
 145:BootloaderDFU.c **** 	MCUCR = 0;
 146:BootloaderDFU.c **** }
 147:BootloaderDFU.c **** 
 148:BootloaderDFU.c **** /** Event handler for the USB_UnhandledControlRequest event. This is used to catch standard and cla
 149:BootloaderDFU.c ****  *  control requests that are not handled internally by the USB library (including the DFU commands
 150:BootloaderDFU.c ****  *  all issued via the control endpoint), so that they can be handled appropriately for the applica
 151:BootloaderDFU.c ****  */
 152:BootloaderDFU.c **** void EVENT_USB_Device_UnhandledControlRequest(void)
 153:BootloaderDFU.c **** {
 154:BootloaderDFU.c **** 	/* Get the size of the command and data from the wLength value */
 155:BootloaderDFU.c **** 	SentCommand.DataSize = USB_ControlRequest.wLength;
 156:BootloaderDFU.c **** 
 157:BootloaderDFU.c **** 	switch (USB_ControlRequest.bRequest)
 158:BootloaderDFU.c **** 	{
 159:BootloaderDFU.c **** 		case REQ_DFU_DNLOAD:
 160:BootloaderDFU.c **** 			Endpoint_ClearSETUP();
 161:BootloaderDFU.c **** 
 162:BootloaderDFU.c **** 			/* Check if bootloader is waiting to terminate */
 163:BootloaderDFU.c **** 			if (WaitForExit)
 164:BootloaderDFU.c **** 			{
 165:BootloaderDFU.c **** 				/* Bootloader is terminating - process last received command */
 166:BootloaderDFU.c **** 				ProcessBootloaderCommand();
 167:BootloaderDFU.c **** 
 168:BootloaderDFU.c **** 				/* Indicate that the last command has now been processed - free to exit bootloader */
 169:BootloaderDFU.c **** 				WaitForExit = false;
 170:BootloaderDFU.c **** 			}
 171:BootloaderDFU.c **** 
 172:BootloaderDFU.c **** 			/* If the request has a data stage, load it into the command struct */
 173:BootloaderDFU.c **** 			if (SentCommand.DataSize)
 174:BootloaderDFU.c **** 			{
 175:BootloaderDFU.c **** 				while (!(Endpoint_IsOUTReceived()))
 176:BootloaderDFU.c **** 				{
 177:BootloaderDFU.c **** 					if (USB_DeviceState == DEVICE_STATE_Unattached)
 178:BootloaderDFU.c **** 					  return;
 179:BootloaderDFU.c **** 				}
 180:BootloaderDFU.c **** 
 181:BootloaderDFU.c **** 				/* First byte of the data stage is the DNLOAD request's command */
 182:BootloaderDFU.c **** 				SentCommand.Command = Endpoint_Read_Byte();
 183:BootloaderDFU.c **** 
 184:BootloaderDFU.c **** 				/* One byte of the data stage is the command, so subtract it from the total data bytes */
 185:BootloaderDFU.c **** 				SentCommand.DataSize--;
 186:BootloaderDFU.c **** 
 187:BootloaderDFU.c **** 				/* Load in the rest of the data stage as command parameters */
 188:BootloaderDFU.c **** 				for (uint8_t DataByte = 0; (DataByte < sizeof(SentCommand.Data)) &&
 189:BootloaderDFU.c **** 				     Endpoint_BytesInEndpoint(); DataByte++)
 190:BootloaderDFU.c **** 				{
 191:BootloaderDFU.c **** 					SentCommand.Data[DataByte] = Endpoint_Read_Byte();
 192:BootloaderDFU.c **** 					SentCommand.DataSize--;
 193:BootloaderDFU.c **** 				}
 194:BootloaderDFU.c **** 
 195:BootloaderDFU.c **** 				/* Process the command */
 196:BootloaderDFU.c **** 				ProcessBootloaderCommand();
 197:BootloaderDFU.c **** 			}
 198:BootloaderDFU.c **** 
 199:BootloaderDFU.c **** 			/* Check if currently downloading firmware */
 200:BootloaderDFU.c **** 			if (DFU_State == dfuDNLOAD_IDLE)
 201:BootloaderDFU.c **** 			{
 202:BootloaderDFU.c **** 				if (!(SentCommand.DataSize))
 203:BootloaderDFU.c **** 				{
 204:BootloaderDFU.c **** 					DFU_State = dfuIDLE;
 205:BootloaderDFU.c **** 				}
 206:BootloaderDFU.c **** 				else
 207:BootloaderDFU.c **** 				{
 208:BootloaderDFU.c **** 					/* Throw away the filler bytes before the start of the firmware */
 209:BootloaderDFU.c **** 					DiscardFillerBytes(DFU_FILLER_BYTES_SIZE);
 210:BootloaderDFU.c **** 
 211:BootloaderDFU.c **** 					/* Throw away the packet alignment filler bytes before the start of the firmware */
 212:BootloaderDFU.c **** 					DiscardFillerBytes(StartAddr % FIXED_CONTROL_ENDPOINT_SIZE);
 213:BootloaderDFU.c **** 
 214:BootloaderDFU.c **** 					/* Calculate the number of bytes remaining to be written */
 215:BootloaderDFU.c **** 					uint16_t BytesRemaining = ((EndAddr - StartAddr) + 1);
 216:BootloaderDFU.c **** 
 217:BootloaderDFU.c **** 					if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00))        // Write flash
 218:BootloaderDFU.c **** 					{
 219:BootloaderDFU.c **** 						/* Calculate the number of words to be written from the number of bytes to be written */
 220:BootloaderDFU.c **** 						uint16_t WordsRemaining = (BytesRemaining >> 1);
 221:BootloaderDFU.c **** 
 222:BootloaderDFU.c **** 						union
 223:BootloaderDFU.c **** 						{
 224:BootloaderDFU.c **** 							uint16_t Words[2];
 225:BootloaderDFU.c **** 							uint32_t Long;
 226:BootloaderDFU.c **** 						} CurrFlashAddress                 = {.Words = {StartAddr, Flash64KBPage}};
 227:BootloaderDFU.c **** 
 228:BootloaderDFU.c **** 						uint32_t CurrFlashPageStartAddress = CurrFlashAddress.Long;
 229:BootloaderDFU.c **** 						uint8_t  WordsInFlashPage          = 0;
 230:BootloaderDFU.c **** 
 231:BootloaderDFU.c **** 						while (WordsRemaining--)
 232:BootloaderDFU.c **** 						{
 233:BootloaderDFU.c **** 							/* Check if endpoint is empty - if so clear it and wait until ready for next packet */
 234:BootloaderDFU.c **** 							if (!(Endpoint_BytesInEndpoint()))
 235:BootloaderDFU.c **** 							{
 236:BootloaderDFU.c **** 								Endpoint_ClearOUT();
 237:BootloaderDFU.c **** 
 238:BootloaderDFU.c **** 								while (!(Endpoint_IsOUTReceived()))
 239:BootloaderDFU.c **** 								{
 240:BootloaderDFU.c **** 									if (USB_DeviceState == DEVICE_STATE_Unattached)
 241:BootloaderDFU.c **** 									  return;
 242:BootloaderDFU.c **** 								}
 243:BootloaderDFU.c **** 							}
 244:BootloaderDFU.c **** 
 245:BootloaderDFU.c **** 							/* Write the next word into the current flash page */
 246:BootloaderDFU.c **** 							boot_page_fill(CurrFlashAddress.Long, Endpoint_Read_Word_LE());
 247:BootloaderDFU.c **** 
 248:BootloaderDFU.c **** 							/* Adjust counters */
 249:BootloaderDFU.c **** 							WordsInFlashPage      += 1;
 250:BootloaderDFU.c **** 							CurrFlashAddress.Long += 2;
 251:BootloaderDFU.c **** 
 252:BootloaderDFU.c **** 							/* See if an entire page has been written to the flash page buffer */
 253:BootloaderDFU.c **** 							if ((WordsInFlashPage == (SPM_PAGESIZE >> 1)) || !(WordsRemaining))
 254:BootloaderDFU.c **** 							{
 255:BootloaderDFU.c **** 								/* Commit the flash page to memory */
 256:BootloaderDFU.c **** 								boot_page_write(CurrFlashPageStartAddress);
 257:BootloaderDFU.c **** 								boot_spm_busy_wait();
 258:BootloaderDFU.c **** 
 259:BootloaderDFU.c **** 								/* Check if programming incomplete */
 260:BootloaderDFU.c **** 								if (WordsRemaining)
 261:BootloaderDFU.c **** 								{
 262:BootloaderDFU.c **** 									CurrFlashPageStartAddress = CurrFlashAddress.Long;
 263:BootloaderDFU.c **** 									WordsInFlashPage          = 0;
 264:BootloaderDFU.c **** 
 265:BootloaderDFU.c **** 									/* Erase next page's temp buffer */
 266:BootloaderDFU.c **** 									boot_page_erase(CurrFlashAddress.Long);
 267:BootloaderDFU.c **** 									boot_spm_busy_wait();
 268:BootloaderDFU.c **** 								}
 269:BootloaderDFU.c **** 							}
 270:BootloaderDFU.c **** 						}
 271:BootloaderDFU.c **** 
 272:BootloaderDFU.c **** 						/* Once programming complete, start address equals the end address */
 273:BootloaderDFU.c **** 						StartAddr = EndAddr;
 274:BootloaderDFU.c **** 
 275:BootloaderDFU.c **** 						/* Re-enable the RWW section of flash */
 276:BootloaderDFU.c **** 						boot_rww_enable();
 277:BootloaderDFU.c **** 					}
 278:BootloaderDFU.c **** 					else                                                   // Write EEPROM
 279:BootloaderDFU.c **** 					{
 280:BootloaderDFU.c **** 						while (BytesRemaining--)
 281:BootloaderDFU.c **** 						{
 282:BootloaderDFU.c **** 							/* Check if endpoint is empty - if so clear it and wait until ready for next packet */
 283:BootloaderDFU.c **** 							if (!(Endpoint_BytesInEndpoint()))
 284:BootloaderDFU.c **** 							{
 285:BootloaderDFU.c **** 								Endpoint_ClearOUT();
 286:BootloaderDFU.c **** 
 287:BootloaderDFU.c **** 								while (!(Endpoint_IsOUTReceived()))
 288:BootloaderDFU.c **** 								{
 289:BootloaderDFU.c **** 									if (USB_DeviceState == DEVICE_STATE_Unattached)
 290:BootloaderDFU.c **** 									  return;
 291:BootloaderDFU.c **** 								}
 292:BootloaderDFU.c **** 							}
 293:BootloaderDFU.c **** 
 294:BootloaderDFU.c **** 							/* Read the byte from the USB interface and write to to the EEPROM */
 295:BootloaderDFU.c **** 							eeprom_write_byte((uint8_t*)StartAddr, Endpoint_Read_Byte());
 296:BootloaderDFU.c **** 
 297:BootloaderDFU.c **** 							/* Adjust counters */
 298:BootloaderDFU.c **** 							StartAddr++;
 299:BootloaderDFU.c **** 						}
 300:BootloaderDFU.c **** 					}
 301:BootloaderDFU.c **** 
 302:BootloaderDFU.c **** 					/* Throw away the currently unused DFU file suffix */
 303:BootloaderDFU.c **** 					DiscardFillerBytes(DFU_FILE_SUFFIX_SIZE);
 304:BootloaderDFU.c **** 				}
 305:BootloaderDFU.c **** 			}
 306:BootloaderDFU.c **** 
 307:BootloaderDFU.c **** 			Endpoint_ClearOUT();
 308:BootloaderDFU.c **** 
 309:BootloaderDFU.c **** 			Endpoint_ClearStatusStage();
 310:BootloaderDFU.c **** 
 311:BootloaderDFU.c **** 			break;
 312:BootloaderDFU.c **** 		case REQ_DFU_UPLOAD:
 313:BootloaderDFU.c **** 			Endpoint_ClearSETUP();
 314:BootloaderDFU.c **** 
 315:BootloaderDFU.c **** 			while (!(Endpoint_IsINReady()))
 316:BootloaderDFU.c **** 			{
 317:BootloaderDFU.c **** 				if (USB_DeviceState == DEVICE_STATE_Unattached)
 318:BootloaderDFU.c **** 				  return;
 319:BootloaderDFU.c **** 			}
 320:BootloaderDFU.c **** 
 321:BootloaderDFU.c **** 			if (DFU_State != dfuUPLOAD_IDLE)
 322:BootloaderDFU.c **** 			{
 323:BootloaderDFU.c **** 				if ((DFU_State == dfuERROR) && IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))       // Blank Check
 324:BootloaderDFU.c **** 				{
 325:BootloaderDFU.c **** 					/* Blank checking is performed in the DFU_DNLOAD request - if we get here we've told the host
 326:BootloaderDFU.c **** 					   that the memory isn't blank, and the host is requesting the first non-blank address */
 327:BootloaderDFU.c **** 					Endpoint_Write_Word_LE(StartAddr);
 328:BootloaderDFU.c **** 				}
 329:BootloaderDFU.c **** 				else
 330:BootloaderDFU.c **** 				{
 331:BootloaderDFU.c **** 					/* Idle state upload - send response to last issued command */
 332:BootloaderDFU.c **** 					Endpoint_Write_Byte(ResponseByte);
 333:BootloaderDFU.c **** 				}
 334:BootloaderDFU.c **** 			}
 335:BootloaderDFU.c **** 			else
 336:BootloaderDFU.c **** 			{
 337:BootloaderDFU.c **** 				/* Determine the number of bytes remaining in the current block */
 338:BootloaderDFU.c **** 				uint16_t BytesRemaining = ((EndAddr - StartAddr) + 1);
 339:BootloaderDFU.c **** 
 340:BootloaderDFU.c **** 				if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00))            // Read FLASH
 341:BootloaderDFU.c **** 				{
 342:BootloaderDFU.c **** 					/* Calculate the number of words to be written from the number of bytes to be written */
 343:BootloaderDFU.c **** 					uint16_t WordsRemaining = (BytesRemaining >> 1);
 344:BootloaderDFU.c **** 
 345:BootloaderDFU.c **** 					union
 346:BootloaderDFU.c **** 					{
 347:BootloaderDFU.c **** 						uint16_t Words[2];
 348:BootloaderDFU.c **** 						uint32_t Long;
 349:BootloaderDFU.c **** 					} CurrFlashAddress = {.Words = {StartAddr, Flash64KBPage}};
 350:BootloaderDFU.c **** 
 351:BootloaderDFU.c **** 					while (WordsRemaining--)
 352:BootloaderDFU.c **** 					{
 353:BootloaderDFU.c **** 						/* Check if endpoint is full - if so clear it and wait until ready for next packet */
 354:BootloaderDFU.c **** 						if (Endpoint_BytesInEndpoint() == FIXED_CONTROL_ENDPOINT_SIZE)
 355:BootloaderDFU.c **** 						{
 356:BootloaderDFU.c **** 							Endpoint_ClearIN();
 357:BootloaderDFU.c **** 
 358:BootloaderDFU.c **** 							while (!(Endpoint_IsINReady()))
 359:BootloaderDFU.c **** 							{
 360:BootloaderDFU.c **** 								if (USB_DeviceState == DEVICE_STATE_Unattached)
 361:BootloaderDFU.c **** 								  return;
 362:BootloaderDFU.c **** 							}
 363:BootloaderDFU.c **** 						}
 364:BootloaderDFU.c **** 
 365:BootloaderDFU.c **** 						/* Read the flash word and send it via USB to the host */
 366:BootloaderDFU.c **** 						#if (FLASHEND > 0xFFFF)
 367:BootloaderDFU.c **** 							Endpoint_Write_Word_LE(pgm_read_word_far(CurrFlashAddress.Long));
 368:BootloaderDFU.c **** 						#else
 369:BootloaderDFU.c **** 							Endpoint_Write_Word_LE(pgm_read_word(CurrFlashAddress.Long));
 370:BootloaderDFU.c **** 						#endif
 371:BootloaderDFU.c **** 
 372:BootloaderDFU.c **** 						/* Adjust counters */
 373:BootloaderDFU.c **** 						CurrFlashAddress.Long += 2;
 374:BootloaderDFU.c **** 					}
 375:BootloaderDFU.c **** 
 376:BootloaderDFU.c **** 					/* Once reading is complete, start address equals the end address */
 377:BootloaderDFU.c **** 					StartAddr = EndAddr;
 378:BootloaderDFU.c **** 				}
 379:BootloaderDFU.c **** 				else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x02))       // Read EEPROM
 380:BootloaderDFU.c **** 				{
 381:BootloaderDFU.c **** 					while (BytesRemaining--)
 382:BootloaderDFU.c **** 					{
 383:BootloaderDFU.c **** 						/* Check if endpoint is full - if so clear it and wait until ready for next packet */
 384:BootloaderDFU.c **** 						if (Endpoint_BytesInEndpoint() == FIXED_CONTROL_ENDPOINT_SIZE)
 385:BootloaderDFU.c **** 						{
 386:BootloaderDFU.c **** 							Endpoint_ClearIN();
 387:BootloaderDFU.c **** 
 388:BootloaderDFU.c **** 							while (!(Endpoint_IsINReady()))
 389:BootloaderDFU.c **** 							{
 390:BootloaderDFU.c **** 								if (USB_DeviceState == DEVICE_STATE_Unattached)
 391:BootloaderDFU.c **** 								  return;
 392:BootloaderDFU.c **** 							}
 393:BootloaderDFU.c **** 						}
 394:BootloaderDFU.c **** 
 395:BootloaderDFU.c **** 						/* Read the EEPROM byte and send it via USB to the host */
 396:BootloaderDFU.c **** 						Endpoint_Write_Byte(eeprom_read_byte((uint8_t*)StartAddr));
 397:BootloaderDFU.c **** 
 398:BootloaderDFU.c **** 						/* Adjust counters */
 399:BootloaderDFU.c **** 						StartAddr++;
 400:BootloaderDFU.c **** 					}
 401:BootloaderDFU.c **** 				}
 402:BootloaderDFU.c **** 
 403:BootloaderDFU.c **** 				/* Return to idle state */
 404:BootloaderDFU.c **** 				DFU_State = dfuIDLE;
 405:BootloaderDFU.c **** 			}
 406:BootloaderDFU.c **** 
 407:BootloaderDFU.c **** 			Endpoint_ClearIN();
 408:BootloaderDFU.c **** 
 409:BootloaderDFU.c **** 			Endpoint_ClearStatusStage();
 410:BootloaderDFU.c **** 			break;
 411:BootloaderDFU.c **** 		case REQ_DFU_GETSTATUS:
 412:BootloaderDFU.c **** 			Endpoint_ClearSETUP();
 413:BootloaderDFU.c **** 
 414:BootloaderDFU.c **** 			/* Write 8-bit status value */
 415:BootloaderDFU.c **** 			Endpoint_Write_Byte(DFU_Status);
 416:BootloaderDFU.c **** 
 417:BootloaderDFU.c **** 			/* Write 24-bit poll timeout value */
 418:BootloaderDFU.c **** 			Endpoint_Write_Byte(0);
 419:BootloaderDFU.c **** 			Endpoint_Write_Word_LE(0);
 420:BootloaderDFU.c **** 
 421:BootloaderDFU.c **** 			/* Write 8-bit state value */
 422:BootloaderDFU.c **** 			Endpoint_Write_Byte(DFU_State);
 423:BootloaderDFU.c **** 
 424:BootloaderDFU.c **** 			/* Write 8-bit state string ID number */
 425:BootloaderDFU.c **** 			Endpoint_Write_Byte(0);
 426:BootloaderDFU.c **** 
 427:BootloaderDFU.c **** 			Endpoint_ClearIN();
 428:BootloaderDFU.c **** 
 429:BootloaderDFU.c **** 			Endpoint_ClearStatusStage();
 430:BootloaderDFU.c **** 			break;
 431:BootloaderDFU.c **** 		case REQ_DFU_CLRSTATUS:
 432:BootloaderDFU.c **** 			Endpoint_ClearSETUP();
 433:BootloaderDFU.c **** 
 434:BootloaderDFU.c **** 			/* Reset the status value variable to the default OK status */
 435:BootloaderDFU.c **** 			DFU_Status = OK;
 436:BootloaderDFU.c **** 
 437:BootloaderDFU.c **** 			Endpoint_ClearStatusStage();
 438:BootloaderDFU.c **** 			break;
 439:BootloaderDFU.c **** 		case REQ_DFU_GETSTATE:
 440:BootloaderDFU.c **** 			Endpoint_ClearSETUP();
 441:BootloaderDFU.c **** 
 442:BootloaderDFU.c **** 			/* Write the current device state to the endpoint */
 443:BootloaderDFU.c **** 			Endpoint_Write_Byte(DFU_State);
 444:BootloaderDFU.c **** 
 445:BootloaderDFU.c **** 			Endpoint_ClearIN();
 446:BootloaderDFU.c **** 
 447:BootloaderDFU.c **** 			Endpoint_ClearStatusStage();
 448:BootloaderDFU.c **** 			break;
 449:BootloaderDFU.c **** 		case REQ_DFU_ABORT:
 450:BootloaderDFU.c **** 			Endpoint_ClearSETUP();
 451:BootloaderDFU.c **** 
 452:BootloaderDFU.c **** 			/* Reset the current state variable to the default idle state */
 453:BootloaderDFU.c **** 			DFU_State = dfuIDLE;
 454:BootloaderDFU.c **** 
 455:BootloaderDFU.c **** 			Endpoint_ClearStatusStage();
 456:BootloaderDFU.c **** 			break;
 457:BootloaderDFU.c **** 	}
 458:BootloaderDFU.c **** }
 459:BootloaderDFU.c **** 
 460:BootloaderDFU.c **** /** Routine to discard the specified number of bytes from the control endpoint stream. This is used
 461:BootloaderDFU.c ****  *  discard unused bytes in the stream from the host, including the memory program block suffix.
 462:BootloaderDFU.c ****  *
 463:BootloaderDFU.c ****  *  \param[in] NumberOfBytes  Number of bytes to discard from the host from the control endpoint
 464:BootloaderDFU.c ****  */
 465:BootloaderDFU.c **** static void DiscardFillerBytes(uint8_t NumberOfBytes)
 466:BootloaderDFU.c **** {
  16               		.loc 1 466 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  23               	.L2:
 467:BootloaderDFU.c **** 	while (NumberOfBytes--)
  24               		.loc 1 467 0
  25 0000 8823      		tst r24
  26 0002 01F0      		breq .L1
  27               	.LBB105:
  28               	.LBB106:
  29               		.file 2 "../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h"
   1:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** /*
   2:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****              LUFA Library
   3:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****      Copyright (C) Dean Camera, 2010.
   4:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
   5:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****       www.fourwalledcubicle.com
   7:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** */
   8:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
   9:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** /*
  10:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   Copyright 2010  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  12:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   software and its documentation for any purpose is hereby granted
  14:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   without fee, provided that the above copyright notice appear in
  15:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   all copies and that both that the copyright notice and this
  16:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   documentation, and that the name of the author not be used in
  18:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   advertising or publicity pertaining to distribution of the
  19:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   software without specific, written prior permission.
  20:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  21:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   The author disclaim all warranties with regard to this
  22:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   software, including all implied warranties of merchantability
  23:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   and fitness.  In no event shall the author be liable for any
  24:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   special, indirect or consequential damages or any damages
  25:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   in an action of contract, negligence or other tortious action,
  27:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   arising out of or in connection with the use or performance of
  28:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   this software.
  29:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** */
  30:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  31:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** /** \file
  32:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  \brief USB device endpoint management definitions.
  33:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *
  34:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  This file contains structures, function prototypes and macros related to the management of the 
  35:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  data endpoints when the library is initialized in USB device mode.
  36:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *
  37:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  38:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *        dispatch header located in LUFA/Drivers/USB/USB.h.
  39:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  */
  40:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  41:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** /** \ingroup Group_EndpointManagement
  42:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  @defgroup Group_EndpointRW Endpoint Data Reading and Writing
  43:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *
  44:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  Functions, macros, variables, enums and types related to data reading and writing from and to e
  45:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  */
  46:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  47:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** /** \ingroup Group_EndpointRW
  48:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  @defgroup Group_EndpointPrimitiveRW Read/Write of Primitive Data Types
  49:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *
  50:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  Functions, macros, variables, enums and types related to data reading and writing of primitive 
  51:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  from and to endpoints.
  52:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  */
  53:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  54:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** /** \ingroup Group_EndpointManagement
  55:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  @defgroup Group_EndpointPacketManagement Endpoint Packet Management
  56:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *
  57:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  Functions, macros, variables, enums and types related to packet management of endpoints.
  58:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  */
  59:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  60:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** /** \ingroup Group_USB
  61:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  @defgroup Group_EndpointManagement Endpoint Management
  62:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *
  63:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  Functions, macros and enums related to endpoint management when in USB Device mode. This
  64:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  module contains the endpoint management macros, as well as endpoint interrupt and data
  65:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  send/receive functions for various data types.
  66:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *
  67:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  @{
  68:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  */
  69:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  70:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** #ifndef __ENDPOINT_H__
  71:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** #define __ENDPOINT_H__
  72:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  73:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 	/* Includes: */
  74:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#include <avr/io.h>
  75:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#include <stdbool.h>
  76:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  77:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#include "../../../Common/Common.h"
  78:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#include "../HighLevel/USBTask.h"
  79:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#include "USBInterrupt.h"
  80:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  81:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 	/* Enable C linkage for C++ Compilers: */
  82:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#if defined(__cplusplus)
  83:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			extern "C" {
  84:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#endif
  85:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  86:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 	/* Preprocessor Checks: */
  87:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#if !defined(__INCLUDE_FROM_USB_DRIVER)
  88:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#error Do not include this file directly. Include LUFA/Drivers/USB/USB.h instead.
  89:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#endif
  90:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  91:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 	/* Private Interface - For use in library only: */
  92:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 	#if !defined(__DOXYGEN__)
  93:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		/* Macros: */
  94:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define _ENDPOINT_GET_MAXSIZE(EPIndex)         _ENDPOINT_GET_MAXSIZE2(ENDPOINT_DETAILS_EP ## EPI
  95:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define _ENDPOINT_GET_MAXSIZE2(EPDetails)      _ENDPOINT_GET_MAXSIZE3(EPDetails)
  96:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define _ENDPOINT_GET_MAXSIZE3(MaxSize, Banks) (MaxSize)
  97:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  98:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define _ENDPOINT_GET_BANKS(EPIndex)           _ENDPOINT_GET_BANKS2(ENDPOINT_DETAILS_EP ## EPInd
  99:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define _ENDPOINT_GET_BANKS2(EPDetails)        _ENDPOINT_GET_BANKS3(EPDetails)
 100:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define _ENDPOINT_GET_BANKS3(MaxSize, Banks)   (Banks)
 101:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 102:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
 103:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_MAXEP             7
 104:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 105:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP0               64,  2
 106:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP1               256, 2
 107:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP2               64,  2
 108:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP3               64,  2
 109:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP4               64,  2
 110:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP5               64,  2
 111:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP6               64,  2
 112:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#else
 113:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_MAXEP             5
 114:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 115:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP0               64,  2
 116:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP1               64,  1
 117:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP2               64,  1
 118:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP3               64,  2
 119:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP4               64,  2
 120:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#endif
 121:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 122:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		/* Inline Functions: */
 123:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT A
 124:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                                                       ATTR_ALWAYS_INLINE;
 125:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
 126:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 127:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				uint8_t  MaskVal    = 0;
 128:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				uint16_t CheckBytes = 8;
 129:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 130:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				while (CheckBytes < Bytes)
 131:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				{
 132:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					MaskVal++;
 133:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					CheckBytes <<= 1;
 134:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				}
 135:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 136:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return (MaskVal << EPSIZE0);
 137:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 138:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 139:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		/* Function Prototypes: */
 140:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			void Endpoint_ClearEndpoints(void);
 141:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			bool Endpoint_ConfigureEndpoint_Prv(const uint8_t Number,
 142:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                    const uint8_t UECFG0XData,
 143:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                    const uint8_t UECFG1XData);
 144:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 145:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 	#endif
 146:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 147:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 	/* Public Interface - May be used in end-application: */
 148:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		/* Macros: */
 149:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Endpoint data direction mask for \ref Endpoint_ConfigureEndpoint(). This indicates that the 
 150:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  should be initialized in the OUT direction - i.e. data flows from host to device.
 151:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 152:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_DIR_OUT                        (0 << EPDIR)
 153:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 154:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Endpoint data direction mask for \ref Endpoint_ConfigureEndpoint(). This indicates that the 
 155:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  should be initialized in the IN direction - i.e. data flows from device to host.
 156:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 157:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_DIR_IN                         (1 << EPDIR)
 158:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 159:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Mask for the bank mode selection for the \ref Endpoint_ConfigureEndpoint() macro. This indic
 160:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  that the endpoint should have one single bank, which requires less USB FIFO memory but resul
 161:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  in slower transfers as only one USB device (the AVR or the host) can access the endpoint's
 162:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  bank at the one time.
 163:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 164:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_BANK_SINGLE                    (0 << EPBK0)
 165:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 166:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Mask for the bank mode selection for the \ref Endpoint_ConfigureEndpoint() macro. This indic
 167:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  that the endpoint should have two banks, which requires more USB FIFO memory but results
 168:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  in faster transfers as one USB device (the AVR or the host) can access one bank while the ot
 169:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  accesses the second bank.
 170:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 171:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_BANK_DOUBLE                    (1 << EPBK0)
 172:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 173:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Endpoint address for the default control endpoint, which always resides in address 0. This i
 174:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  defined for convenience to give more readable code when used with the endpoint macros.
 175:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 176:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_CONTROLEP                      0
 177:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 178:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#if (!defined(FIXED_CONTROL_ENDPOINT_SIZE) || defined(__DOXYGEN__))
 179:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				/** Default size of the default control endpoint's bank, until altered by the control endpoint 
 180:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				 *  value in the device descriptor. Not available if the FIXED_CONTROL_ENDPOINT_SIZE token is d
 181:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				 */
 182:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_CONTROLEP_DEFAULT_SIZE     8
 183:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#endif
 184:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 185:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Endpoint number mask, for masking against endpoint addresses to retrieve the endpoint's
 186:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  numerical address in the device.
 187:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 188:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_EPNUM_MASK                     0x07
 189:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 190:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Endpoint direction mask, for masking against endpoint addresses to retrieve the endpoint's
 191:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  direction for comparing with the ENDPOINT_DESCRIPTOR_DIR_* masks.
 192:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 193:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_EPDIR_MASK                     0x80
 194:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 195:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Endpoint bank size mask, for masking against endpoint addresses to retrieve the endpoint's
 196:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  bank size in the device.
 197:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 198:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_EPSIZE_MASK                    0x7F
 199:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 200:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Maximum size in bytes of a given endpoint.
 201:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 202:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] EPIndex  Endpoint number, a value between 0 and (ENDPOINT_TOTAL_ENDPOINTS - 1)
 203:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 204:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_MAX_SIZE(EPIndex)              _ENDPOINT_GET_MAXSIZE(EPIndex)
 205:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 206:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Indicates the total number of banks supported by the given endpoint.
 207:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 208:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] EPIndex  Endpoint number, a value between 0 and (ENDPOINT_TOTAL_ENDPOINTS - 1)
 209:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 210:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_BANKS_SUPPORTED(EPIndex)       _ENDPOINT_GET_BANKS(EPIndex)
 211:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 212:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#if !defined(CONTROL_ONLY_DEVICE) || defined(__DOXYGEN__)
 213:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				/** Total number of endpoints (including the default control endpoint at address 0) which may
 214:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				 *  be used in the device. Different USB AVR models support different amounts of endpoints,
 215:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				 *  this value reflects the maximum number of endpoints for the currently selected AVR model.
 216:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				 */
 217:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_TOTAL_ENDPOINTS            ENDPOINT_DETAILS_MAXEP
 218:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#else
 219:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_TOTAL_ENDPOINTS            1
 220:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#endif
 221:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 222:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		/* Enums: */
 223:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Enum for the possible error return codes of the \ref Endpoint_WaitUntilReady() function.
 224:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 225:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointRW
 226:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 227:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			enum Endpoint_WaitUntilReady_ErrorCodes_t
 228:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 229:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_READYWAIT_NoError                 = 0, /**< Endpoint is ready for next packet, no erro
 230:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_READYWAIT_EndpointStalled         = 1, /**< The endpoint was stalled during the stream
 231:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 *   transfer by the host or device.
 232:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 */
 233:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_READYWAIT_DeviceDisconnected      = 2,	/**< Device was disconnected from the host whil
 234:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 *   waiting for the endpoint to become ready.
 235:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 */
 236:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_READYWAIT_BusSuspended            = 3, /**< The USB bus has been suspended by the host
 237:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 *   no USB endpoint traffic can occur until th
 238:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 *   has resumed.
 239:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 */
 240:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_READYWAIT_Timeout                 = 4, /**< The host failed to accept or send the next
 241:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 *   within the software timeout period set by 
 242:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 *   \ref USB_STREAM_TIMEOUT_MS macro.
 243:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 */
 244:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			};
 245:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 246:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		/* Inline Functions: */
 247:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Configures the specified endpoint number with the given endpoint type, direction, bank size
 248:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  and banking mode. Once configured, the endpoint may be read from or written to, depending
 249:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  on its direction.
 250:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 251:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Number     Endpoint number to configure. This must be more than 0 and less than
 252:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *                        \ref ENDPOINT_TOTAL_ENDPOINTS.
 253:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 254:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Type       Type of endpoint to configure, a EP_TYPE_* mask. Not all endpoint type
 255:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *                        are available on Low Speed USB devices - refer to the USB 2.0 specific
 256:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 257:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Direction  Endpoint data direction, either \ref ENDPOINT_DIR_OUT or \ref ENDPOINT
 258:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *                        All endpoints (except Control type) are unidirectional - data may only
 259:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *                        from or written to the endpoint bank based on its direction, not both.
 260:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 261:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Size       Size of the endpoint's bank, where packets are stored before they are 
 262:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *                        to the USB host, or after they have been received from the USB host (d
 263:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *                        the endpoint's data direction). The bank size must indicate the maximu
 264:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *                        that the endpoint can handle.
 265:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 266:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Banks      Number of banks to use for the endpoint being configured, an ENDPOINT_
 267:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *                        More banks uses more USB DPRAM, but offers better performance. Isochro
 268:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *                        endpoints <b>must</b> have at least two banks.
 269:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 270:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note Endpoints <b>must</b> be configured in ascending order, or bank corruption will occur.
 271:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        \n\n
 272:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 273:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note Certain models of USB AVR's endpoints may have different maximum packet sizes based on
 274:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        index - refer to the chosen USB AVR's datasheet to determine the maximum bank size for
 275:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        \n\n
 276:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 277:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note The default control endpoint should not be manually configured by the user application
 278:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        it is automatically configured by the library internally.
 279:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        \n\n
 280:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 281:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine will automatically select the specified endpoint upon success. Upon failu
 282:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        which failed to reconfigure correctly will be selected.
 283:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 284:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Boolean true if the configuration succeeded, false otherwise.
 285:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 286:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Number,
 287:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                              const uint8_t Type,
 288:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                              const uint8_t Direction,
 289:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                              const uint16_t Size,
 290:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                              const uint8_t Banks) ATTR_ALWAYS_INLINE;
 291:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Number,
 292:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                              const uint8_t Type,
 293:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                              const uint8_t Direction,
 294:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                              const uint16_t Size,
 295:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                              const uint8_t Banks)
 296:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 297:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return Endpoint_ConfigureEndpoint_Prv(Number, (((Type) << EPTYPE0) | (Direction)),
 298:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                      ((1 << ALLOC) | Banks | Endpoint_BytesToEPSizeMask(Size))
 299:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 300:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 301:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Indicates the number of bytes currently stored in the current endpoint's selected bank.
 302:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 303:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note The return width of this function may differ, depending on the maximum endpoint bank s
 304:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        of the selected AVR model.
 305:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 306:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointRW
 307:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 308:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
 309:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 310:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE
 311:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint16_t Endpoint_BytesInEndpoint(void)
 312:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 313:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
 314:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					return UEBCX;
  30               		.loc 2 314 0
  31 0004 2091 F200 		lds r18,242
  32 0008 3091 F300 		lds r19,242+1
  33               	.LBE106:
  34               	.LBE105:
 468:BootloaderDFU.c **** 	{
 469:BootloaderDFU.c **** 		if (!(Endpoint_BytesInEndpoint()))
  35               		.loc 1 469 0
  36 000c 232B      		or r18,r19
  37 000e 01F4      		brne .L3
  38               	.LBB107:
  39               	.LBB108:
 315:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#elif defined(USB_SERIES_4_AVR)
 316:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					return (((uint16_t)UEBCHX << 8) | UEBCLX);
 317:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#elif defined(USB_SERIES_2_AVR)
 318:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					return UEBCLX;
 319:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif
 320:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 321:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 322:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Get the endpoint address of the currently selected endpoint. This is typically used to save
 323:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  the currently selected endpoint number so that it can be restored after another endpoint has
 324:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  been manipulated.
 325:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 326:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Index of the currently selected endpoint.
 327:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 328:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLI
 329:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
 330:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 331:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#if !defined(CONTROL_ONLY_DEVICE)
 332:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					return (UENUM & ENDPOINT_EPNUM_MASK);
 333:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#else
 334:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					return ENDPOINT_CONTROLEP;
 335:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif
 336:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 337:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 338:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Selects the given endpoint number. If the address from the device descriptors is used, the
 339:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  value should be masked with the \ref ENDPOINT_EPNUM_MASK constant to extract only the endpoi
 340:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  number (and discarding the endpoint direction bit).
 341:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 342:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  Any endpoint operations which do not require the endpoint number to be indicated will operat
 343:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  the currently selected endpoint.
 344:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 345:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] EndpointNumber Endpoint number to select.
 346:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 347:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
 348:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
 349:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 350:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#if !defined(CONTROL_ONLY_DEVICE)
 351:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					UENUM = EndpointNumber;
 352:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif
 353:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 354:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 355:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Resets the endpoint bank FIFO. This clears all the endpoint banks and resets the USB control
 356:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  In and Out pointers to the bank's contents.
 357:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 358:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
 359:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 360:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
 361:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber)
 362:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 363:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UERST = (1 << EndpointNumber);
 364:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UERST = 0;
 365:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 366:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 367:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Enables the currently selected endpoint so that data can be sent and received through it to
 368:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  and from a host.
 369:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 370:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
 371:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 372:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
 373:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_EnableEndpoint(void)
 374:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 375:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UECONX |= (1 << EPEN);
 376:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 377:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 378:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Disables the currently selected endpoint so that data cannot be sent and received through it
 379:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  to and from a host.
 380:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 381:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
 382:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_DisableEndpoint(void)
 383:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 384:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UECONX &= ~(1 << EPEN);
 385:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 386:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 387:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines if the currently selected endpoint is enabled, but not necessarily configured.
 388:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 389:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 * \return Boolean True if the currently selected endpoint is enabled, false otherwise.
 390:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 391:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 392:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsEnabled(void)
 393:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 394:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return ((UECONX & (1 << EPEN)) ? true : false);
 395:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 396:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 397:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines if the currently selected endpoint may be read from (if data is waiting in the en
 398:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  bank and the endpoint is an OUT direction, or if the bank is not yet full if the endpoint is
 399:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  direction). This function will return false if an error has occurred in the endpoint, if the
 400:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  is an OUT direction and no packet (or an empty packet) has been received, or if the endpoint
 401:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  direction and the endpoint bank is full.
 402:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 403:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 404:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 405:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depe
 406:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 407:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 408:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsReadWriteAllowed(void)
 409:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 410:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return ((UEINTX & (1 << RWAL)) ? true : false);
 411:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 412:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 413:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines if the currently selected endpoint is configured.
 414:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 415:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Boolean true if the currently selected endpoint has been configured, false otherwise
 416:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 417:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 418:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsConfigured(void)
 419:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 420:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return ((UESTA0X & (1 << CFGOK)) ? true : false);
 421:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 422:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 423:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Returns a mask indicating which INTERRUPT type endpoints have interrupted - i.e. their
 424:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  interrupt duration has elapsed. Which endpoints have interrupted can be determined by
 425:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  masking the return value against (1 << {Endpoint Number}).
 426:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 427:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Mask whose bits indicate which endpoints have interrupted.
 428:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 429:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_GetEndpointInterrupts(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_I
 430:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_GetEndpointInterrupts(void)
 431:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 432:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return UEINT;
 433:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 434:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 435:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines if the specified endpoint number has interrupted (valid only for INTERRUPT type
 436:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  endpoints).
 437:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 438:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] EndpointNumber  Index of the endpoint whose interrupt flag should be tested.
 439:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 440:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Boolean true if the specified endpoint has interrupted, false otherwise.
 441:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 442:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_HasEndpointInterrupted(const uint8_t EndpointNumber) ATTR_WARN_UNUSE
 443:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_HasEndpointInterrupted(const uint8_t EndpointNumber)
 444:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 445:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return ((UEINT & (1 << EndpointNumber)) ? true : false);
 446:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 447:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 448:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines if the selected IN endpoint is ready for a new packet to be sent to the host.
 449:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 450:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 451:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 452:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
 453:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 454:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 455:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsINReady(void)
 456:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 457:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return ((UEINTX & (1 << TXINI)) ? true : false);
 458:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 459:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 460:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines if the selected OUT endpoint has received new packet from the host.
 461:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 462:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 463:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 464:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
 465:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 466:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 467:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsOUTReceived(void)
 468:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 469:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return ((UEINTX & (1 << RXOUTI)) ? true : false);
 470:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 471:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 472:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines if the current CONTROL type endpoint has received a SETUP packet.
 473:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 474:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 475:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 476:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
 477:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 478:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 479:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsSETUPReceived(void)
 480:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 481:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return ((UEINTX & (1 << RXSTPI)) ? true : false);
 482:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 483:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 484:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Clears a received SETUP packet on the currently selected CONTROL type endpoint, freeing up t
 485:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  endpoint for the next packet.
 486:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 487:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 488:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 489:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This is not applicable for non CONTROL type endpoints.
 490:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 491:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
 492:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ClearSETUP(void)
 493:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 494:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEINTX &= ~(1 << RXSTPI);
 495:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 496:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 497:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Sends an IN packet to the host on the currently selected endpoint, freeing up the endpoint f
 498:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  next packet and switching to the alternative endpoint bank if double banked.
 499:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 500:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 501:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 502:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
 503:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ClearIN(void)
 504:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 505:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#if !defined(CONTROL_ONLY_DEVICE)
 506:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
 507:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#else
 508:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					UEINTX &= ~(1 << TXINI);
 509:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif
 510:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 511:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 512:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Acknowledges an OUT packet to the host on the currently selected endpoint, freeing up the en
 513:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  for the next packet and switching to the alternative endpoint bank if double banked.
 514:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 515:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 516:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 517:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
 518:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ClearOUT(void)
 519:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 520:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#if !defined(CONTROL_ONLY_DEVICE)
 521:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 522:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#else
 523:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					UEINTX &= ~(1 << RXOUTI);
  40               		.loc 2 523 0
  41 0010 9091 E800 		lds r25,232
  42 0014 9B7F      		andi r25,lo8(-5)
  43 0016 9093 E800 		sts 232,r25
  44               	.L4:
  45               	.LBE108:
  46               	.LBE107:
  47               	.LBB109:
  48               	.LBB110:
 469:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
  49               		.loc 2 469 0
  50 001a 9091 E800 		lds r25,232
  51               	.LBE110:
  52               	.LBE109:
 470:BootloaderDFU.c **** 		{
 471:BootloaderDFU.c **** 			Endpoint_ClearOUT();
 472:BootloaderDFU.c **** 
 473:BootloaderDFU.c **** 			/* Wait until next data packet received */
 474:BootloaderDFU.c **** 			while (!(Endpoint_IsOUTReceived()))
  53               		.loc 1 474 0
  54 001e 92FD      		sbrc r25,2
  55 0020 00C0      		rjmp .L6
 475:BootloaderDFU.c **** 			{
 476:BootloaderDFU.c **** 				if (USB_DeviceState == DEVICE_STATE_Unattached)
  56               		.loc 1 476 0
  57 0022 9EB3      		in r25,0x1e
  58 0024 9111      		cpse r25,__zero_reg__
  59 0026 00C0      		rjmp .L4
  60 0028 00C0      		rjmp .L1
  61               	.L3:
  62               	.LBB111:
  63               	.LBB112:
 524:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif
 525:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 526:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 527:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Stalls the current endpoint, indicating to the host that a logical problem occurred with the
 528:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  indicated endpoint and that the current transfer sequence should be aborted. This provides a
 529:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  way for devices to indicate invalid commands to the host so that the current transfer can be
 530:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  aborted and the host can begin its own recovery sequence.
 531:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 532:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  The currently selected endpoint remains stalled until either the \ref Endpoint_ClearStall() 
 533:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  is called, or the host issues a CLEAR FEATURE request to the device for the currently select
 534:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  endpoint.
 535:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 536:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 537:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 538:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
 539:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_StallTransaction(void)
 540:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 541:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UECONX |= (1 << STALLRQ);
 542:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 543:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 544:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Clears the STALL condition on the currently selected endpoint.
 545:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 546:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 547:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 548:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
 549:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ClearStall(void)
 550:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 551:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UECONX |= (1 << STALLRQC);
 552:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 553:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 554:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines if the currently selected endpoint is stalled, false otherwise.
 555:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 556:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 557:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 558:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Boolean true if the currently selected endpoint is stalled, false otherwise.
 559:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 560:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 561:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsStalled(void)
 562:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 563:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return ((UECONX & (1 << STALLRQ)) ? true : false);
 564:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 565:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 566:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Resets the data toggle of the currently selected endpoint. */
 567:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
 568:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ResetDataToggle(void)
 569:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 570:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UECONX |= (1 << RSTDT);
 571:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 572:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 573:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines the currently selected endpoint's direction.
 574:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 575:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return The currently selected endpoint's direction, as a ENDPOINT_DIR_* mask.
 576:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 577:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_IN
 578:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_GetEndpointDirection(void)
 579:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 580:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return (UECFG0X & ENDPOINT_DIR_IN);
 581:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 582:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 583:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Sets the direction of the currently selected endpoint.
 584:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 585:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] DirectionMask  New endpoint direction, as a ENDPOINT_DIR_* mask.
 586:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 587:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_SetEndpointDirection(const uint8_t DirectionMask) ATTR_ALWAYS_INLINE
 588:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_SetEndpointDirection(const uint8_t DirectionMask)
 589:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 590:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UECFG0X = ((UECFG0X & ~ENDPOINT_DIR_IN) | DirectionMask);
 591:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 592:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 593:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Reads one byte from the currently selected endpoint's bank, for OUT direction endpoints.
 594:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 595:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 596:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 597:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
 598:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 599:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 600:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_Read_Byte(void)
 601:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 602:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return UEDATX;
 603:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 604:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 605:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Writes one byte from the currently selected endpoint's bank, for IN direction endpoints.
 606:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 607:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 608:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 609:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
 610:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 611:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
 612:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Write_Byte(const uint8_t Byte)
 613:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 614:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEDATX = Byte;
 615:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 616:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 617:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Discards one byte from the currently selected endpoint's bank, for OUT direction endpoints.
 618:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 619:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 620:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 621:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Discard_Byte(void) ATTR_ALWAYS_INLINE;
 622:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Discard_Byte(void)
 623:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 624:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				uint8_t Dummy;
 625:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 626:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Dummy = UEDATX;
  64               		.loc 2 626 0
  65 002a 9091 F100 		lds r25,241
  66               	.L6:
  67               	.LBE112:
  68               	.LBE111:
 467:BootloaderDFU.c **** 	{
  69               		.loc 1 467 0
  70 002e 8150      		subi r24,lo8(-(-1))
  71               	.LVL1:
  72 0030 00C0      		rjmp .L2
  73               	.LVL2:
  74               	.L1:
  75 0032 0895      		ret
  76               		.cfi_endproc
  77               	.LFE78:
  79               		.section	.text.LoadStartEndAddresses,"ax",@progbits
  81               	LoadStartEndAddresses:
  82               	.LFB80:
 477:BootloaderDFU.c **** 				  return;
 478:BootloaderDFU.c **** 			}
 479:BootloaderDFU.c **** 		}
 480:BootloaderDFU.c **** 		else
 481:BootloaderDFU.c **** 		{
 482:BootloaderDFU.c **** 			Endpoint_Discard_Byte();
 483:BootloaderDFU.c **** 		}
 484:BootloaderDFU.c **** 	}
 485:BootloaderDFU.c **** }
 486:BootloaderDFU.c **** 
 487:BootloaderDFU.c **** /** Routine to process an issued command from the host, via a DFU_DNLOAD request wrapper. This rout
 488:BootloaderDFU.c ****  *  that the command is allowed based on the current secure mode flag value, and passes the command
 489:BootloaderDFU.c ****  *  appropriate handler function.
 490:BootloaderDFU.c ****  */
 491:BootloaderDFU.c **** static void ProcessBootloaderCommand(void)
 492:BootloaderDFU.c **** {
 493:BootloaderDFU.c **** 	/* Check if device is in secure mode */
 494:BootloaderDFU.c **** 	if (IsSecure)
 495:BootloaderDFU.c **** 	{
 496:BootloaderDFU.c **** 		/* Don't process command unless it is a READ or chip erase command */
 497:BootloaderDFU.c **** 		if (!(((SentCommand.Command == COMMAND_WRITE)             &&
 498:BootloaderDFU.c **** 		        IS_TWOBYTE_COMMAND(SentCommand.Data, 0x00, 0xFF)) ||
 499:BootloaderDFU.c **** 			   (SentCommand.Command == COMMAND_READ)))
 500:BootloaderDFU.c **** 		{
 501:BootloaderDFU.c **** 			/* Set the state and status variables to indicate the error */
 502:BootloaderDFU.c **** 			DFU_State  = dfuERROR;
 503:BootloaderDFU.c **** 			DFU_Status = errWRITE;
 504:BootloaderDFU.c **** 
 505:BootloaderDFU.c **** 			/* Stall command */
 506:BootloaderDFU.c **** 			Endpoint_StallTransaction();
 507:BootloaderDFU.c **** 
 508:BootloaderDFU.c **** 			/* Don't process the command */
 509:BootloaderDFU.c **** 			return;
 510:BootloaderDFU.c **** 		}
 511:BootloaderDFU.c **** 	}
 512:BootloaderDFU.c **** 
 513:BootloaderDFU.c **** 	/* Dispatch the required command processing routine based on the command type */
 514:BootloaderDFU.c **** 	switch (SentCommand.Command)
 515:BootloaderDFU.c **** 	{
 516:BootloaderDFU.c **** 		case COMMAND_PROG_START:
 517:BootloaderDFU.c **** 			ProcessMemProgCommand();
 518:BootloaderDFU.c **** 			break;
 519:BootloaderDFU.c **** 		case COMMAND_DISP_DATA:
 520:BootloaderDFU.c **** 			ProcessMemReadCommand();
 521:BootloaderDFU.c **** 			break;
 522:BootloaderDFU.c **** 		case COMMAND_WRITE:
 523:BootloaderDFU.c **** 			ProcessWriteCommand();
 524:BootloaderDFU.c **** 			break;
 525:BootloaderDFU.c **** 		case COMMAND_READ:
 526:BootloaderDFU.c **** 			ProcessReadCommand();
 527:BootloaderDFU.c **** 			break;
 528:BootloaderDFU.c **** 		case COMMAND_CHANGE_BASE_ADDR:
 529:BootloaderDFU.c **** 			if (IS_TWOBYTE_COMMAND(SentCommand.Data, 0x03, 0x00))              // Set 64KB flash page comman
 530:BootloaderDFU.c **** 			  Flash64KBPage = SentCommand.Data[2];
 531:BootloaderDFU.c **** 
 532:BootloaderDFU.c **** 			break;
 533:BootloaderDFU.c **** 	}
 534:BootloaderDFU.c **** }
 535:BootloaderDFU.c **** 
 536:BootloaderDFU.c **** /** Routine to concatenate the given pair of 16-bit memory start and end addresses from the host, a
 537:BootloaderDFU.c ****  *  in the StartAddr and EndAddr global variables.
 538:BootloaderDFU.c ****  */
 539:BootloaderDFU.c **** static void LoadStartEndAddresses(void)
 540:BootloaderDFU.c **** {
  83               		.loc 1 540 0
  84               		.cfi_startproc
  85               	/* prologue: function */
  86               	/* frame size = 0 */
  87               	/* stack size = 0 */
  88               	.L__stack_usage = 0
 541:BootloaderDFU.c **** 	union
 542:BootloaderDFU.c **** 	{
 543:BootloaderDFU.c **** 		uint8_t  Bytes[2];
 544:BootloaderDFU.c **** 		uint16_t Word;
 545:BootloaderDFU.c **** 	} Address[2] = {{.Bytes = {SentCommand.Data[2], SentCommand.Data[1]}},
  89               		.loc 1 545 0
  90 0000 E0E0      		ldi r30,lo8(SentCommand)
  91 0002 F0E0      		ldi r31,hi8(SentCommand)
  92 0004 3581      		ldd r19,Z+5
  93               	.LVL3:
  94 0006 2481      		ldd r18,Z+4
 546:BootloaderDFU.c **** 	                {.Bytes = {SentCommand.Data[4], SentCommand.Data[3]}}};
 547:BootloaderDFU.c **** 
 548:BootloaderDFU.c **** 	/* Load in the start and ending read addresses from the sent data packet */
 549:BootloaderDFU.c **** 	StartAddr = Address[0].Word;
  95               		.loc 1 549 0
  96 0008 9381      		ldd r25,Z+3
  97 000a 8281      		ldd r24,Z+2
  98 000c 9093 0000 		sts StartAddr,r25
  99 0010 8093 0000 		sts StartAddr+1,r24
 550:BootloaderDFU.c **** 	EndAddr   = Address[1].Word;
 100               		.loc 1 550 0
 101 0014 C901      		movw r24,r18
 102 0016 9093 0000 		sts EndAddr,r25
 103 001a 8093 0000 		sts EndAddr+1,r24
 104 001e 0895      		ret
 105               		.cfi_endproc
 106               	.LFE80:
 108               		.section	.text.ProcessBootloaderCommand,"ax",@progbits
 110               	ProcessBootloaderCommand:
 111               	.LFB79:
 492:BootloaderDFU.c **** 	/* Check if device is in secure mode */
 112               		.loc 1 492 0
 113               		.cfi_startproc
 114 0000 CF93      		push r28
 115               	.LCFI0:
 116               		.cfi_def_cfa_offset 3
 117               		.cfi_offset 28, -2
 118 0002 DF93      		push r29
 119               	.LCFI1:
 120               		.cfi_def_cfa_offset 4
 121               		.cfi_offset 29, -3
 122 0004 00D0      		rcall .
 123 0006 00D0      		rcall .
 124 0008 00D0      		rcall .
 125               	.LCFI2:
 126               		.cfi_def_cfa_offset 10
 127 000a CDB7      		in r28,__SP_L__
 128 000c DEB7      		in r29,__SP_H__
 129               	.LCFI3:
 130               		.cfi_def_cfa_register 28
 131               	/* prologue: function */
 132               	/* frame size = 6 */
 133               	/* stack size = 8 */
 134               	.L__stack_usage = 8
 494:BootloaderDFU.c **** 	{
 135               		.loc 1 494 0
 136 000e 9091 0000 		lds r25,IsSecure
 137 0012 8091 0000 		lds r24,SentCommand
 138 0016 9923      		tst r25
 139 0018 01F0      		breq .L13
 497:BootloaderDFU.c **** 		        IS_TWOBYTE_COMMAND(SentCommand.Data, 0x00, 0xFF)) ||
 140               		.loc 1 497 0
 141 001a 8430      		cpi r24,lo8(4)
 142 001c 01F4      		brne .L14
 497:BootloaderDFU.c **** 		        IS_TWOBYTE_COMMAND(SentCommand.Data, 0x00, 0xFF)) ||
 143               		.loc 1 497 0 is_stmt 0 discriminator 2
 144 001e 8091 0000 		lds r24,SentCommand+1
 145 0022 8111      		cpse r24,__zero_reg__
 146 0024 00C0      		rjmp .L15
 498:BootloaderDFU.c **** 			   (SentCommand.Command == COMMAND_READ)))
 147               		.loc 1 498 0 is_stmt 1
 148 0026 8091 0000 		lds r24,SentCommand+2
 149 002a 8F3F      		cpi r24,lo8(-1)
 150 002c 01F4      		brne .L15
 151 002e 00C0      		rjmp .L17
 152               	.L14:
 497:BootloaderDFU.c **** 		        IS_TWOBYTE_COMMAND(SentCommand.Data, 0x00, 0xFF)) ||
 153               		.loc 1 497 0 discriminator 3
 154 0030 8530      		cpi r24,lo8(5)
 155 0032 01F4      		brne .+2
 156 0034 00C0      		rjmp .L21
 157               	.L15:
 502:BootloaderDFU.c **** 			DFU_Status = errWRITE;
 158               		.loc 1 502 0
 159 0036 8AE0      		ldi r24,lo8(10)
 160 0038 8093 0000 		sts DFU_State,r24
 503:BootloaderDFU.c **** 
 161               		.loc 1 503 0
 162 003c 83E0      		ldi r24,lo8(3)
 163 003e 8093 0000 		sts DFU_Status,r24
 164               	.LBB130:
 165               	.LBB131:
 541:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 166               		.loc 2 541 0
 167 0042 8091 EB00 		lds r24,235
 168 0046 8062      		ori r24,lo8(32)
 169 0048 8093 EB00 		sts 235,r24
 170 004c 00C0      		rjmp .L12
 171               	.L13:
 172               	.LBE131:
 173               	.LBE130:
 514:BootloaderDFU.c **** 	{
 174               		.loc 1 514 0
 175 004e 8430      		cpi r24,lo8(4)
 176 0050 01F4      		brne .+2
 177 0052 00C0      		rjmp .L17
 178 0054 00F4      		brsh .L18
 179 0056 8130      		cpi r24,lo8(1)
 180 0058 01F0      		breq .L19
 181 005a 8330      		cpi r24,lo8(3)
 182 005c 01F0      		breq .L20
 183 005e 00C0      		rjmp .L12
 184               	.L18:
 185 0060 8530      		cpi r24,lo8(5)
 186 0062 01F4      		brne .+2
 187 0064 00C0      		rjmp .L21
 188 0066 8630      		cpi r24,lo8(6)
 189 0068 01F4      		brne .+2
 190 006a 00C0      		rjmp .L22
 191 006c 00C0      		rjmp .L12
 192               	.L19:
 193               	.LBB132:
 194               	.LBB133:
 551:BootloaderDFU.c **** }
 552:BootloaderDFU.c **** 
 553:BootloaderDFU.c **** /** Handler for a Memory Program command issued by the host. This routine handles the preparations 
 554:BootloaderDFU.c ****  *  to write subsequent data from the host into the specified memory.
 555:BootloaderDFU.c ****  */
 556:BootloaderDFU.c **** static void ProcessMemProgCommand(void)
 557:BootloaderDFU.c **** {
 558:BootloaderDFU.c **** 	if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00) ||                          // Write FLASH command
 195               		.loc 1 558 0
 196 006e 8091 0000 		lds r24,SentCommand+1
 197 0072 8230      		cpi r24,lo8(2)
 198 0074 00F0      		brlo .+2
 199 0076 00C0      		rjmp .L12
 559:BootloaderDFU.c **** 	    IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))                            // Write EEPROM command
 560:BootloaderDFU.c **** 	{
 561:BootloaderDFU.c **** 		/* Load in the start and ending read addresses */
 562:BootloaderDFU.c **** 		LoadStartEndAddresses();
 200               		.loc 1 562 0
 201 0078 0E94 0000 		call LoadStartEndAddresses
 202               	.LVL4:
 563:BootloaderDFU.c **** 
 564:BootloaderDFU.c **** 		/* If FLASH is being written to, we need to pre-erase the first page to write to */
 565:BootloaderDFU.c **** 		if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00))
 203               		.loc 1 565 0
 204 007c 8091 0000 		lds r24,SentCommand+1
 205 0080 8111      		cpse r24,__zero_reg__
 206 0082 00C0      		rjmp .L24
 207               	.LBB134:
 566:BootloaderDFU.c **** 		{
 567:BootloaderDFU.c **** 			union
 568:BootloaderDFU.c **** 			{
 569:BootloaderDFU.c **** 				uint16_t Words[2];
 570:BootloaderDFU.c **** 				uint32_t Long;
 571:BootloaderDFU.c **** 			} CurrFlashAddress = {.Words = {StartAddr, Flash64KBPage}};
 208               		.loc 1 571 0
 209 0084 8091 0000 		lds r24,StartAddr
 210 0088 9091 0000 		lds r25,StartAddr+1
 211               	.LVL5:
 212 008c 2091 0000 		lds r18,Flash64KBPage
 213 0090 A22F      		mov r26,r18
 214 0092 B0E0      		ldi r27,0
 572:BootloaderDFU.c **** 
 573:BootloaderDFU.c **** 			/* Erase the current page's temp buffer */
 574:BootloaderDFU.c **** 			boot_page_erase(CurrFlashAddress.Long);
 215               		.loc 1 574 0
 216 0094 23E0      		ldi r18,lo8(3)
 217               	.LVL6:
 218               	/* #APP */
 219               	 ;  574 "BootloaderDFU.c" 1
 220 0096 FC01      		movw r30, r24
 221 0098 A093 5B00 		sts  91, r26
 222 009c 2093 5700 		sts 87, r18
 223 00a0 E895      		spm
 224               		
 225               	 ;  0 "" 2
 226               	/* #NOAPP */
 227               	.L25:
 575:BootloaderDFU.c **** 			boot_spm_busy_wait();
 228               		.loc 1 575 0
 229 00a2 07B6      		in __tmp_reg__,0x37
 230 00a4 00FC      		sbrc __tmp_reg__,0
 231 00a6 00C0      		rjmp .L25
 232               	.L24:
 233               	.LBE134:
 576:BootloaderDFU.c **** 		}
 577:BootloaderDFU.c **** 
 578:BootloaderDFU.c **** 		/* Set the state so that the next DNLOAD requests reads in the firmware */
 579:BootloaderDFU.c **** 		DFU_State = dfuDNLOAD_IDLE;
 234               		.loc 1 579 0
 235 00a8 85E0      		ldi r24,lo8(5)
 236               	.LVL7:
 237 00aa 00C0      		rjmp .L49
 238               	.L20:
 239               	.LBE133:
 240               	.LBE132:
 241               	.LBB135:
 242               	.LBB136:
 580:BootloaderDFU.c **** 	}
 581:BootloaderDFU.c **** }
 582:BootloaderDFU.c **** 
 583:BootloaderDFU.c **** /** Handler for a Memory Read command issued by the host. This routine handles the preparations nee
 584:BootloaderDFU.c ****  *  to read subsequent data from the specified memory out to the host, as well as implementing the 
 585:BootloaderDFU.c ****  *  blank check command.
 586:BootloaderDFU.c ****  */
 587:BootloaderDFU.c **** static void ProcessMemReadCommand(void)
 588:BootloaderDFU.c **** {
 589:BootloaderDFU.c **** 	if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00) ||                          // Read FLASH command
 243               		.loc 1 589 0
 244 00ac 8091 0000 		lds r24,SentCommand+1
 245 00b0 982F      		mov r25,r24
 246 00b2 9D7F      		andi r25,lo8(-3)
 247 00b4 01F4      		brne .L26
 590:BootloaderDFU.c ****         IS_ONEBYTE_COMMAND(SentCommand.Data, 0x02))                            // Read EEPROM comma
 591:BootloaderDFU.c **** 	{
 592:BootloaderDFU.c **** 		/* Load in the start and ending read addresses */
 593:BootloaderDFU.c **** 		LoadStartEndAddresses();
 248               		.loc 1 593 0
 249 00b6 0E94 0000 		call LoadStartEndAddresses
 250               	.LVL8:
 594:BootloaderDFU.c **** 
 595:BootloaderDFU.c **** 		/* Set the state so that the next UPLOAD requests read out the firmware */
 596:BootloaderDFU.c **** 		DFU_State = dfuUPLOAD_IDLE;
 251               		.loc 1 596 0
 252 00ba 89E0      		ldi r24,lo8(9)
 253               	.L49:
 254 00bc 8093 0000 		sts DFU_State,r24
 255 00c0 00C0      		rjmp .L12
 256               	.L26:
 597:BootloaderDFU.c **** 	}
 598:BootloaderDFU.c **** 	else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))                       // Blank check FLASH co
 257               		.loc 1 598 0
 258 00c2 8130      		cpi r24,lo8(1)
 259 00c4 01F0      		breq .+2
 260 00c6 00C0      		rjmp .L12
 261 00c8 80E0      		ldi r24,0
 262 00ca 90E0      		ldi r25,0
 263 00cc DC01      		movw r26,r24
 264               	.L29:
 265               	.LVL9:
 266               	.LBB137:
 267               	.LBB138:
 599:BootloaderDFU.c **** 	{
 600:BootloaderDFU.c **** 		uint32_t CurrFlashAddress = 0;
 601:BootloaderDFU.c **** 
 602:BootloaderDFU.c **** 		while (CurrFlashAddress < BOOT_START_ADDR)
 603:BootloaderDFU.c **** 		{
 604:BootloaderDFU.c **** 			/* Check if the current byte is not blank */
 605:BootloaderDFU.c **** 			#if (FLASHEND > 0xFFFF)
 606:BootloaderDFU.c **** 			if (pgm_read_byte_far(CurrFlashAddress) != 0xFF)
 268               		.loc 1 606 0
 269               	/* #APP */
 270               	 ;  606 "BootloaderDFU.c" 1
 271 00ce ABBF      		out 59, r26
 272 00d0 FC01      		movw r30, r24
 273 00d2 2791      		elpm r18, Z+
 274               		
 275               	 ;  0 "" 2
 276               	.LVL10:
 277               	/* #NOAPP */
 278               	.LBE138:
 279 00d4 2F3F      		cpi r18,lo8(-1)
 280 00d6 01F0      		breq .L28
 607:BootloaderDFU.c **** 			#else
 608:BootloaderDFU.c **** 			if (pgm_read_byte(CurrFlashAddress) != 0xFF)
 609:BootloaderDFU.c **** 			#endif
 610:BootloaderDFU.c **** 			{
 611:BootloaderDFU.c **** 				/* Save the location of the first non-blank byte for response back to the host */
 612:BootloaderDFU.c **** 				Flash64KBPage = (CurrFlashAddress >> 16);
 281               		.loc 1 612 0
 282 00d8 A093 0000 		sts Flash64KBPage,r26
 613:BootloaderDFU.c **** 				StartAddr     = CurrFlashAddress;
 283               		.loc 1 613 0
 284 00dc 9093 0000 		sts StartAddr+1,r25
 285 00e0 8093 0000 		sts StartAddr,r24
 614:BootloaderDFU.c **** 
 615:BootloaderDFU.c **** 				/* Set state and status variables to the appropriate error values */
 616:BootloaderDFU.c **** 				DFU_State  = dfuERROR;
 286               		.loc 1 616 0
 287 00e4 8AE0      		ldi r24,lo8(10)
 288               	.LVL11:
 289 00e6 8093 0000 		sts DFU_State,r24
 617:BootloaderDFU.c **** 				DFU_Status = errCHECK_ERASED;
 290               		.loc 1 617 0
 291 00ea 85E0      		ldi r24,lo8(5)
 292 00ec 8093 0000 		sts DFU_Status,r24
 293 00f0 00C0      		rjmp .L12
 294               	.LVL12:
 295               	.L28:
 618:BootloaderDFU.c **** 
 619:BootloaderDFU.c **** 				break;
 620:BootloaderDFU.c **** 			}
 621:BootloaderDFU.c **** 
 622:BootloaderDFU.c **** 			CurrFlashAddress++;
 296               		.loc 1 622 0
 297 00f2 0196      		adiw r24,1
 298 00f4 A11D      		adc r26,__zero_reg__
 299 00f6 B11D      		adc r27,__zero_reg__
 300               	.LVL13:
 602:BootloaderDFU.c **** 		{
 301               		.loc 1 602 0
 302 00f8 8115      		cp r24,__zero_reg__
 303 00fa 20EE      		ldi r18,-32
 304 00fc 9207      		cpc r25,r18
 305 00fe 21E0      		ldi r18,1
 306 0100 A207      		cpc r26,r18
 307 0102 B105      		cpc r27,__zero_reg__
 308               	.LVL14:
 309 0104 01F4      		brne .L29
 310 0106 00C0      		rjmp .L12
 311               	.LVL15:
 312               	.L17:
 313               	.LBE137:
 314               	.LBE136:
 315               	.LBE135:
 316               	.LBB139:
 317               	.LBB140:
 623:BootloaderDFU.c **** 		}
 624:BootloaderDFU.c **** 	}
 625:BootloaderDFU.c **** }
 626:BootloaderDFU.c **** 
 627:BootloaderDFU.c **** /** Handler for a Data Write command issued by the host. This routine handles non-programming comma
 628:BootloaderDFU.c ****  *  bootloader exit (both via software jumps and hardware watchdog resets) and flash memory erasure
 629:BootloaderDFU.c ****  */
 630:BootloaderDFU.c **** static void ProcessWriteCommand(void)
 631:BootloaderDFU.c **** {
 632:BootloaderDFU.c **** 	if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x03))                            // Start application
 318               		.loc 1 632 0
 319 0108 8091 0000 		lds r24,SentCommand+1
 320 010c 8330      		cpi r24,lo8(3)
 321 010e 01F4      		brne .L30
 633:BootloaderDFU.c **** 	{
 634:BootloaderDFU.c **** 		/* Indicate that the bootloader is terminating */
 635:BootloaderDFU.c **** 		WaitForExit = true;
 322               		.loc 1 635 0
 323 0110 81E0      		ldi r24,lo8(1)
 324 0112 8093 0000 		sts WaitForExit,r24
 636:BootloaderDFU.c **** 
 637:BootloaderDFU.c **** 		/* Check if data supplied for the Start Program command - no data executes the program */
 638:BootloaderDFU.c **** 		if (SentCommand.DataSize)
 325               		.loc 1 638 0
 326 0116 2091 0000 		lds r18,SentCommand+6
 327 011a 3091 0000 		lds r19,SentCommand+6+1
 328 011e 8091 0000 		lds r24,SentCommand+2
 329 0122 232B      		or r18,r19
 330 0124 01F0      		breq .L31
 639:BootloaderDFU.c **** 		{
 640:BootloaderDFU.c **** 			if (SentCommand.Data[1] == 0x01)                                   // Start via jump
 331               		.loc 1 640 0
 332 0126 8130      		cpi r24,lo8(1)
 333 0128 01F0      		breq .+2
 334 012a 00C0      		rjmp .L12
 335               	.LBB141:
 641:BootloaderDFU.c **** 			{
 642:BootloaderDFU.c **** 				union
 643:BootloaderDFU.c **** 				{
 644:BootloaderDFU.c **** 					uint8_t  Bytes[2];
 645:BootloaderDFU.c **** 					AppPtr_t FuncPtr;
 646:BootloaderDFU.c **** 				} Address = {.Bytes = {SentCommand.Data[4], SentCommand.Data[3]}};
 336               		.loc 1 646 0
 337 012c 9091 0000 		lds r25,SentCommand+5
 338               	.LVL16:
 339 0130 8091 0000 		lds r24,SentCommand+4
 647:BootloaderDFU.c **** 
 648:BootloaderDFU.c **** 				/* Load in the jump address into the application start address pointer */
 649:BootloaderDFU.c **** 				AppStartPtr = Address.FuncPtr;
 340               		.loc 1 649 0
 341 0134 9093 0000 		sts AppStartPtr,r25
 342               	.LVL17:
 343 0138 8093 0000 		sts AppStartPtr+1,r24
 344 013c 00C0      		rjmp .L12
 345               	.LVL18:
 346               	.L31:
 347               	.LBE141:
 650:BootloaderDFU.c **** 			}
 651:BootloaderDFU.c **** 		}
 652:BootloaderDFU.c **** 		else
 653:BootloaderDFU.c **** 		{
 654:BootloaderDFU.c **** 			if (SentCommand.Data[1] == 0x00)                                   // Start via watchdog
 348               		.loc 1 654 0
 349 013e 8111      		cpse r24,__zero_reg__
 350 0140 00C0      		rjmp .L32
 351               	.LVL19:
 352               	.LBB142:
 353               	.LBB143:
 354               		.file 3 "/usr/lib/avr/include/avr/wdt.h"
   1:/usr/lib/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/lib/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/lib/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/wdt.h **** 
   5:/usr/lib/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/wdt.h **** 
   8:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/wdt.h **** 
  11:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/avr/wdt.h ****      distribution.
  15:/usr/lib/avr/include/avr/wdt.h **** 
  16:/usr/lib/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/avr/wdt.h **** 
  20:/usr/lib/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/avr/wdt.h **** 
  32:/usr/lib/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/lib/avr/include/avr/wdt.h **** 
  34:/usr/lib/avr/include/avr/wdt.h **** /*
  35:/usr/lib/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/lib/avr/include/avr/wdt.h ****  */
  37:/usr/lib/avr/include/avr/wdt.h **** 
  38:/usr/lib/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/lib/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/lib/avr/include/avr/wdt.h **** 
  41:/usr/lib/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/lib/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/lib/avr/include/avr/wdt.h **** 
  44:/usr/lib/avr/include/avr/wdt.h **** /** \file */
  45:/usr/lib/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/lib/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/lib/avr/include/avr/wdt.h **** 
  48:/usr/lib/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/lib/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/lib/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/lib/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/lib/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/lib/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/lib/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/lib/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/lib/avr/include/avr/wdt.h **** 
  57:/usr/lib/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/lib/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/lib/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/lib/avr/include/avr/wdt.h **** 
  61:/usr/lib/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/lib/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/lib/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/lib/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/lib/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/lib/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/lib/avr/include/avr/wdt.h ****     the following:
  68:/usr/lib/avr/include/avr/wdt.h **** 
  69:/usr/lib/avr/include/avr/wdt.h ****     \code
  70:/usr/lib/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/lib/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/lib/avr/include/avr/wdt.h **** 
  73:/usr/lib/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/lib/avr/include/avr/wdt.h **** 
  75:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/lib/avr/include/avr/wdt.h ****     {
  80:/usr/lib/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/lib/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/lib/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/lib/avr/include/avr/wdt.h ****     }
  84:/usr/lib/avr/include/avr/wdt.h ****     \endcode
  85:/usr/lib/avr/include/avr/wdt.h **** 
  86:/usr/lib/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/lib/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/lib/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/lib/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/lib/avr/include/avr/wdt.h **** */
  91:/usr/lib/avr/include/avr/wdt.h **** 
  92:/usr/lib/avr/include/avr/wdt.h **** /**
  93:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/lib/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/lib/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/lib/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/lib/avr/include/avr/wdt.h **** */
  98:/usr/lib/avr/include/avr/wdt.h **** 
  99:/usr/lib/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/lib/avr/include/avr/wdt.h **** 
 101:/usr/lib/avr/include/avr/wdt.h **** 
 102:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDP3)
 103:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 104:/usr/lib/avr/include/avr/wdt.h **** #else
 105:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 106:/usr/lib/avr/include/avr/wdt.h **** #endif
 107:/usr/lib/avr/include/avr/wdt.h **** 
 108:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 109:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 110:/usr/lib/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 111:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 112:/usr/lib/avr/include/avr/wdt.h **** #else
 113:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 114:/usr/lib/avr/include/avr/wdt.h **** #endif
 115:/usr/lib/avr/include/avr/wdt.h **** 
 116:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTOE)
 117:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 118:/usr/lib/avr/include/avr/wdt.h **** #else
 119:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 120:/usr/lib/avr/include/avr/wdt.h **** #endif
 121:/usr/lib/avr/include/avr/wdt.h **** 
 122:/usr/lib/avr/include/avr/wdt.h **** 
 123:/usr/lib/avr/include/avr/wdt.h **** /**
 124:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 125:/usr/lib/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 126:/usr/lib/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 127:/usr/lib/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 128:/usr/lib/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 129:/usr/lib/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 130:/usr/lib/avr/include/avr/wdt.h **** 
 131:/usr/lib/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 132:/usr/lib/avr/include/avr/wdt.h **** */
 133:/usr/lib/avr/include/avr/wdt.h **** 
 134:/usr/lib/avr/include/avr/wdt.h **** 
 135:/usr/lib/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 136:/usr/lib/avr/include/avr/wdt.h **** 
 137:/usr/lib/avr/include/avr/wdt.h **** /*
 138:/usr/lib/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 139:/usr/lib/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 140:/usr/lib/avr/include/avr/wdt.h ****    registers to the CCP register
 141:/usr/lib/avr/include/avr/wdt.h **** ** At the same time,
 142:/usr/lib/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 143:/usr/lib/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 144:/usr/lib/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 145:/usr/lib/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 146:/usr/lib/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 147:/usr/lib/avr/include/avr/wdt.h ****    sync is finished).
 148:/usr/lib/avr/include/avr/wdt.h **** */
 149:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 150:/usr/lib/avr/include/avr/wdt.h **** do { \
 151:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 152:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 153:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 154:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 155:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 156:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 157:/usr/lib/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 158:/usr/lib/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 159:/usr/lib/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 160:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 161:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 162:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 163:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 164:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 165:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 166:/usr/lib/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 167:/usr/lib/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 168:/usr/lib/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 169:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 170:/usr/lib/avr/include/avr/wdt.h **** ); \
 171:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 172:/usr/lib/avr/include/avr/wdt.h **** 
 173:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 174:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 175:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 176:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 177:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 178:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 179:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 180:/usr/lib/avr/include/avr/wdt.h ****     : \
 181:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 182:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 183:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 184:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 185:/usr/lib/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 186:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 187:/usr/lib/avr/include/avr/wdt.h **** );
 188:/usr/lib/avr/include/avr/wdt.h **** 
 189:/usr/lib/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 190:/usr/lib/avr/include/avr/wdt.h **** 
 191:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 192:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 193:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 194:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 195:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 196:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 197:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 198:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 199:/usr/lib/avr/include/avr/wdt.h ****     : /* no outputs */  \
 200:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 201:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 202:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 203:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 204:/usr/lib/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 205:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 206:/usr/lib/avr/include/avr/wdt.h **** )
 207:/usr/lib/avr/include/avr/wdt.h **** 
 208:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 209:/usr/lib/avr/include/avr/wdt.h **** do { \
 210:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 211:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 212:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 213:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 214:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 215:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 216:/usr/lib/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 217:/usr/lib/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 218:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 219:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 220:/usr/lib/avr/include/avr/wdt.h ****     : /*no output */ \
 221:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 222:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 223:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 224:/usr/lib/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 225:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 226:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 227:/usr/lib/avr/include/avr/wdt.h **** ); \
 228:/usr/lib/avr/include/avr/wdt.h **** }while(0)
 229:/usr/lib/avr/include/avr/wdt.h **** 
 230:/usr/lib/avr/include/avr/wdt.h **** #elif defined(CCP)
 231:/usr/lib/avr/include/avr/wdt.h **** 
 232:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 233:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 234:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 235:/usr/lib/avr/include/avr/wdt.h **** {
 236:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 237:/usr/lib/avr/include/avr/wdt.h **** 	{
 238:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 239:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 240:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 241:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 242:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 243:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 244:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 245:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 246:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 247:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 248:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 249:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 250:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 251:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 252:/usr/lib/avr/include/avr/wdt.h **** 			);
 253:/usr/lib/avr/include/avr/wdt.h **** 	}
 254:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 255:/usr/lib/avr/include/avr/wdt.h **** 	{
 256:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 257:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 258:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 259:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 260:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 261:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 262:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 263:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 264:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 265:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 266:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 267:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 268:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 269:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 270:/usr/lib/avr/include/avr/wdt.h **** 			);
 271:/usr/lib/avr/include/avr/wdt.h **** 	}
 272:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 273:/usr/lib/avr/include/avr/wdt.h **** 	{
 274:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 275:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 276:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 277:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 278:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 279:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 280:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 281:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 282:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 283:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 284:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 285:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 286:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 287:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 288:/usr/lib/avr/include/avr/wdt.h **** 			);
 289:/usr/lib/avr/include/avr/wdt.h **** 	}
 290:/usr/lib/avr/include/avr/wdt.h **** 	else
 291:/usr/lib/avr/include/avr/wdt.h ****  	{
 292:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 293:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 294:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 295:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 296:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 297:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 298:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 299:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 300:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 301:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 302:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 303:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 304:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 305:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 306:/usr/lib/avr/include/avr/wdt.h **** 			);
 307:/usr/lib/avr/include/avr/wdt.h **** 	}
 308:/usr/lib/avr/include/avr/wdt.h **** }
 309:/usr/lib/avr/include/avr/wdt.h **** 
 310:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 311:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 312:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 313:/usr/lib/avr/include/avr/wdt.h **** {
 314:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 315:/usr/lib/avr/include/avr/wdt.h **** 	{
 316:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 317:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 318:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 319:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 320:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 321:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 322:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 323:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 324:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 325:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 326:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 327:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 328:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 329:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 330:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 331:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 332:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 333:/usr/lib/avr/include/avr/wdt.h **** 				);
 334:/usr/lib/avr/include/avr/wdt.h **** 	}
 335:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 336:/usr/lib/avr/include/avr/wdt.h **** 	{
 337:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 338:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 339:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 340:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 341:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 342:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 343:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 344:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 345:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 346:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 348:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 349:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 352:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 353:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 354:/usr/lib/avr/include/avr/wdt.h **** 				);
 355:/usr/lib/avr/include/avr/wdt.h **** 	}
 356:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 357:/usr/lib/avr/include/avr/wdt.h **** 	{
 358:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 359:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 360:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 361:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 362:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 363:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 364:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 365:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 366:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 367:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 368:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 369:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 370:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 371:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 372:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 373:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 374:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 375:/usr/lib/avr/include/avr/wdt.h **** 				);
 376:/usr/lib/avr/include/avr/wdt.h **** 	}
 377:/usr/lib/avr/include/avr/wdt.h **** 	else
 378:/usr/lib/avr/include/avr/wdt.h **** 	{
 379:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 380:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 381:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 382:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 383:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 384:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 385:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 386:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 387:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 388:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 389:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 390:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 391:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 392:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 393:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 394:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 395:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 396:/usr/lib/avr/include/avr/wdt.h **** 				);
 397:/usr/lib/avr/include/avr/wdt.h **** 	}
 398:/usr/lib/avr/include/avr/wdt.h **** }
 399:/usr/lib/avr/include/avr/wdt.h **** 
 400:/usr/lib/avr/include/avr/wdt.h **** #else
 401:/usr/lib/avr/include/avr/wdt.h **** 
 402:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 403:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 404:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 405:/usr/lib/avr/include/avr/wdt.h **** {
 406:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 407:/usr/lib/avr/include/avr/wdt.h **** 	{
 408:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 409:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 410:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 411:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 412:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 413:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 414:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 415:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 416:/usr/lib/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 417:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 418:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 419:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 420:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 421:/usr/lib/avr/include/avr/wdt.h **** 		);
 422:/usr/lib/avr/include/avr/wdt.h **** 	}
 423:/usr/lib/avr/include/avr/wdt.h **** 	else
 424:/usr/lib/avr/include/avr/wdt.h **** 	{
 425:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 355               		.loc 3 425 0
 356 0142 9CE0      		ldi r25,lo8(12)
 357 0144 88E1      		ldi r24,lo8(24)
 358               	/* #APP */
 359               	 ;  425 "/usr/lib/avr/include/avr/wdt.h" 1
 360 0146 0FB6      		in __tmp_reg__,__SREG__
 361 0148 F894      		cli
 362 014a A895      		wdr
 363 014c 8093 6000 		sts 96, r24
 364 0150 0FBE      		out __SREG__,__tmp_reg__
 365 0152 9093 6000 		sts 96, r25
 366               	 	
 367               	 ;  0 "" 2
 368               	/* #NOAPP */
 369 0156 00C0      		rjmp .L12
 370               	.LVL20:
 371               	.L32:
 372               	.LBE143:
 373               	.LBE142:
 655:BootloaderDFU.c **** 			{
 656:BootloaderDFU.c **** 				/* Start the watchdog to reset the AVR once the communications are finalized */
 657:BootloaderDFU.c **** 				wdt_enable(WDTO_250MS);
 658:BootloaderDFU.c **** 			}
 659:BootloaderDFU.c **** 			else                                                               // Start via jump
 660:BootloaderDFU.c **** 			{
 661:BootloaderDFU.c **** 				/* Set the flag to terminate the bootloader at next opportunity */
 662:BootloaderDFU.c **** 				RunBootloader = false;
 374               		.loc 1 662 0
 375 0158 1092 0000 		sts RunBootloader,__zero_reg__
 376 015c 00C0      		rjmp .L12
 377               	.L30:
 663:BootloaderDFU.c **** 			}
 664:BootloaderDFU.c **** 		}
 665:BootloaderDFU.c **** 	}
 666:BootloaderDFU.c **** 	else if (IS_TWOBYTE_COMMAND(SentCommand.Data, 0x00, 0xFF))                 // Erase flash
 378               		.loc 1 666 0
 379 015e 8111      		cpse r24,__zero_reg__
 380 0160 00C0      		rjmp .L12
 381 0162 8091 0000 		lds r24,SentCommand+2
 382 0166 8F3F      		cpi r24,lo8(-1)
 383 0168 01F0      		breq .+2
 384 016a 00C0      		rjmp .L12
 385 016c 80E0      		ldi r24,0
 386 016e 90E0      		ldi r25,0
 387 0170 DC01      		movw r26,r24
 388               	.LBB144:
 667:BootloaderDFU.c **** 	{
 668:BootloaderDFU.c **** 		uint32_t CurrFlashAddress = 0;
 669:BootloaderDFU.c **** 
 670:BootloaderDFU.c **** 		/* Clear the application section of flash */
 671:BootloaderDFU.c **** 		while (CurrFlashAddress < BOOT_START_ADDR)
 672:BootloaderDFU.c **** 		{
 673:BootloaderDFU.c **** 			boot_page_erase(CurrFlashAddress);
 389               		.loc 1 673 0
 390 0172 23E0      		ldi r18,lo8(3)
 674:BootloaderDFU.c **** 			boot_spm_busy_wait();
 675:BootloaderDFU.c **** 			boot_page_write(CurrFlashAddress);
 391               		.loc 1 675 0
 392 0174 35E0      		ldi r19,lo8(5)
 393               	.L35:
 394               	.LVL21:
 673:BootloaderDFU.c **** 			boot_spm_busy_wait();
 395               		.loc 1 673 0
 396               	/* #APP */
 397               	 ;  673 "BootloaderDFU.c" 1
 398 0176 FC01      		movw r30, r24
 399 0178 A093 5B00 		sts  91, r26
 400 017c 2093 5700 		sts 87, r18
 401 0180 E895      		spm
 402               		
 403               	 ;  0 "" 2
 404               	/* #NOAPP */
 405               	.L33:
 674:BootloaderDFU.c **** 			boot_spm_busy_wait();
 406               		.loc 1 674 0
 407 0182 07B6      		in __tmp_reg__,0x37
 408 0184 00FC      		sbrc __tmp_reg__,0
 409 0186 00C0      		rjmp .L33
 410               		.loc 1 675 0
 411               	/* #APP */
 412               	 ;  675 "BootloaderDFU.c" 1
 413 0188 FC01      		movw r30, r24
 414 018a A093 5B00 		sts 91, r26
 415 018e 3093 5700 		sts 87, r19
 416 0192 E895      		spm
 417               		
 418               	 ;  0 "" 2
 419               	/* #NOAPP */
 420               	.L34:
 676:BootloaderDFU.c **** 			boot_spm_busy_wait();
 421               		.loc 1 676 0
 422 0194 07B6      		in __tmp_reg__,0x37
 423 0196 00FC      		sbrc __tmp_reg__,0
 424 0198 00C0      		rjmp .L34
 677:BootloaderDFU.c **** 
 678:BootloaderDFU.c **** 			CurrFlashAddress += SPM_PAGESIZE;
 425               		.loc 1 678 0
 426 019a 9F5F      		subi r25,-1
 427 019c AF4F      		sbci r26,-1
 428 019e BF4F      		sbci r27,-1
 429               	.LVL22:
 671:BootloaderDFU.c **** 		{
 430               		.loc 1 671 0
 431 01a0 8115      		cp r24,__zero_reg__
 432 01a2 40EE      		ldi r20,-32
 433 01a4 9407      		cpc r25,r20
 434 01a6 41E0      		ldi r20,1
 435 01a8 A407      		cpc r26,r20
 436 01aa B105      		cpc r27,__zero_reg__
 437 01ac 01F4      		brne .L35
 679:BootloaderDFU.c **** 		}
 680:BootloaderDFU.c **** 
 681:BootloaderDFU.c **** 		/* Re-enable the RWW section of flash as writing to the flash locks it out */
 682:BootloaderDFU.c **** 		boot_rww_enable();
 438               		.loc 1 682 0
 439 01ae 81E1      		ldi r24,lo8(17)
 440               	.LVL23:
 441               	/* #APP */
 442               	 ;  682 "BootloaderDFU.c" 1
 443 01b0 8093 5700 		sts 87, r24
 444 01b4 E895      		spm
 445               		
 446               	 ;  0 "" 2
 683:BootloaderDFU.c **** 
 684:BootloaderDFU.c **** 		/* Memory has been erased, reset the security bit so that programming/reading is allowed */
 685:BootloaderDFU.c **** 		IsSecure = false;
 447               		.loc 1 685 0
 448               	/* #NOAPP */
 449 01b6 1092 0000 		sts IsSecure,__zero_reg__
 450 01ba 00C0      		rjmp .L12
 451               	.L21:
 452               	.LBE144:
 453               	.LBE140:
 454               	.LBE139:
 455               	.LBB145:
 456               	.LBB146:
 686:BootloaderDFU.c **** 	}
 687:BootloaderDFU.c **** }
 688:BootloaderDFU.c **** 
 689:BootloaderDFU.c **** /** Handler for a Data Read command issued by the host. This routine handles bootloader information
 690:BootloaderDFU.c ****  *  commands such as device signature and bootloader version retrieval.
 691:BootloaderDFU.c ****  */
 692:BootloaderDFU.c **** static void ProcessReadCommand(void)
 693:BootloaderDFU.c **** {
 694:BootloaderDFU.c **** 	const uint8_t BootloaderInfo[3] = {BOOTLOADER_VERSION, BOOTLOADER_ID_BYTE1, BOOTLOADER_ID_BYTE2};
 457               		.loc 1 694 0
 458 01bc 80E2      		ldi r24,lo8(32)
 459 01be 8C83      		std Y+4,r24
 460 01c0 8CED      		ldi r24,lo8(-36)
 461 01c2 8D83      		std Y+5,r24
 462 01c4 8BEF      		ldi r24,lo8(-5)
 463 01c6 8E83      		std Y+6,r24
 695:BootloaderDFU.c **** 	const uint8_t SignatureInfo[3]  = {AVR_SIGNATURE_1,    AVR_SIGNATURE_2,     AVR_SIGNATURE_3};
 464               		.loc 1 695 0
 465 01c8 8EE1      		ldi r24,lo8(30)
 466 01ca 8983      		std Y+1,r24
 467 01cc 87E9      		ldi r24,lo8(-105)
 468 01ce 8A83      		std Y+2,r24
 469 01d0 82E8      		ldi r24,lo8(-126)
 470 01d2 8B83      		std Y+3,r24
 696:BootloaderDFU.c **** 
 697:BootloaderDFU.c **** 	uint8_t DataIndexToRead = SentCommand.Data[1];
 471               		.loc 1 697 0
 472 01d4 8091 0000 		lds r24,SentCommand+2
 473               	.LVL24:
 698:BootloaderDFU.c **** 
 699:BootloaderDFU.c **** 	if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00))                         // Read bootloader info
 474               		.loc 1 699 0
 475 01d8 9091 0000 		lds r25,SentCommand+1
 476 01dc 9111      		cpse r25,__zero_reg__
 477 01de 00C0      		rjmp .L36
 700:BootloaderDFU.c **** 	  ResponseByte = BootloaderInfo[DataIndexToRead];
 478               		.loc 1 700 0
 479 01e0 FE01      		movw r30,r28
 480 01e2 E80F      		add r30,r24
 481 01e4 F11D      		adc r31,__zero_reg__
 482 01e6 8481      		ldd r24,Z+4
 483               	.LVL25:
 484 01e8 00C0      		rjmp .L50
 485               	.LVL26:
 486               	.L36:
 701:BootloaderDFU.c **** 	else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))                    // Read signature byte
 487               		.loc 1 701 0
 488 01ea 9130      		cpi r25,lo8(1)
 489 01ec 01F4      		brne .L12
 702:BootloaderDFU.c **** 	  ResponseByte = SignatureInfo[DataIndexToRead - 0x30];
 490               		.loc 1 702 0
 491 01ee E1ED      		ldi r30,lo8(-47)
 492 01f0 FFEF      		ldi r31,lo8(-1)
 493 01f2 EC0F      		add r30,r28
 494 01f4 FD1F      		adc r31,r29
 495 01f6 E80F      		add r30,r24
 496 01f8 F11D      		adc r31,__zero_reg__
 497 01fa 8081      		ld r24,Z
 498               	.LVL27:
 499               	.L50:
 500 01fc 8093 0000 		sts ResponseByte,r24
 501 0200 00C0      		rjmp .L12
 502               	.LVL28:
 503               	.L22:
 504               	.LBE146:
 505               	.LBE145:
 529:BootloaderDFU.c **** 			  Flash64KBPage = SentCommand.Data[2];
 506               		.loc 1 529 0
 507 0202 8091 0000 		lds r24,SentCommand+1
 508 0206 8330      		cpi r24,lo8(3)
 509 0208 01F4      		brne .L12
 529:BootloaderDFU.c **** 			  Flash64KBPage = SentCommand.Data[2];
 510               		.loc 1 529 0 is_stmt 0 discriminator 1
 511 020a 8091 0000 		lds r24,SentCommand+2
 512 020e 8111      		cpse r24,__zero_reg__
 513 0210 00C0      		rjmp .L12
 530:BootloaderDFU.c **** 
 514               		.loc 1 530 0 is_stmt 1
 515 0212 8091 0000 		lds r24,SentCommand+3
 516 0216 8093 0000 		sts Flash64KBPage,r24
 517               	.LVL29:
 518               	.L12:
 519               	/* epilogue start */
 534:BootloaderDFU.c **** 
 520               		.loc 1 534 0
 521 021a 2696      		adiw r28,6
 522 021c 0FB6      		in __tmp_reg__,__SREG__
 523 021e F894      		cli
 524 0220 DEBF      		out __SP_H__,r29
 525 0222 0FBE      		out __SREG__,__tmp_reg__
 526 0224 CDBF      		out __SP_L__,r28
 527 0226 DF91      		pop r29
 528 0228 CF91      		pop r28
 529 022a 0895      		ret
 530               		.cfi_endproc
 531               	.LFE79:
 533               		.section	.text.SetupHardware,"ax",@progbits
 534               	.global	SetupHardware
 536               	SetupHardware:
 537               	.LFB75:
 121:BootloaderDFU.c **** 	/* Disable watchdog if enabled by bootloader/fuses */
 538               		.loc 1 121 0
 539               		.cfi_startproc
 540               	/* prologue: function */
 541               	/* frame size = 0 */
 542               	/* stack size = 0 */
 543               	.L__stack_usage = 0
 123:BootloaderDFU.c **** 	wdt_disable();
 544               		.loc 1 123 0
 545 0000 84B7      		in r24,0x34
 546 0002 877F      		andi r24,lo8(-9)
 547 0004 84BF      		out 0x34,r24
 548               	.LBB147:
 549               	.LBB148:
 426:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 427:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 428:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 429:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %1" "\n\t"
 430:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 431:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %2" "\n \t"
 432:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 433:/usr/lib/avr/include/avr/wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 434:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 435:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 436:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 437:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 438:/usr/lib/avr/include/avr/wdt.h **** 		);
 439:/usr/lib/avr/include/avr/wdt.h **** 	}
 440:/usr/lib/avr/include/avr/wdt.h **** }
 441:/usr/lib/avr/include/avr/wdt.h **** 
 442:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 443:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 444:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 445:/usr/lib/avr/include/avr/wdt.h **** {
 446:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 447:/usr/lib/avr/include/avr/wdt.h **** 	{
 448:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 449:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 450:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__"    "\n\t"
 451:/usr/lib/avr/include/avr/wdt.h **** 				"cli"                        "\n\t"
 452:/usr/lib/avr/include/avr/wdt.h **** 				"wdr"                        "\n\t"
 453:/usr/lib/avr/include/avr/wdt.h **** 				"in  %[TEMPREG],%[WDTREG]"   "\n\t"
 454:/usr/lib/avr/include/avr/wdt.h **** 				"ori %[TEMPREG],%[WDCE_WDE]" "\n\t"
 455:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMPREG]"   "\n\t"
 456:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],__zero_reg__" "\n\t"
 457:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__"   "\n\t"
 458:/usr/lib/avr/include/avr/wdt.h **** 				: [TEMPREG] "=d" (temp_reg)
 459:/usr/lib/avr/include/avr/wdt.h **** 				: [WDTREG]  "I"  (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 460:/usr/lib/avr/include/avr/wdt.h **** 				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
 461:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 462:/usr/lib/avr/include/avr/wdt.h **** 		);
 463:/usr/lib/avr/include/avr/wdt.h **** 	}
 464:/usr/lib/avr/include/avr/wdt.h **** 	else
 465:/usr/lib/avr/include/avr/wdt.h **** 	{
 466:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 467:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 550               		.loc 3 467 0
 551               	/* #APP */
 552               	 ;  467 "/usr/lib/avr/include/avr/wdt.h" 1
 553 0006 0FB6      		in __tmp_reg__,__SREG__
 554 0008 F894      		cli
 555 000a A895      		wdr
 556 000c 8091 6000 		lds r24,96
 557 0010 8861      		ori r24,24
 558 0012 8093 6000 		sts 96,r24
 559 0016 1092 6000 		sts 96,__zero_reg__
 560 001a 0FBE      		out __SREG__,__tmp_reg__
 561               		
 562               	 ;  0 "" 2
 563               	.LVL30:
 564               	/* #NOAPP */
 565               	.LBE148:
 566               	.LBE147:
 567               	.LBB149:
 568               	.LBB150:
 569               		.file 4 "/usr/lib/avr/include/avr/power.h"
   1:/usr/lib/avr/include/avr/power.h **** /* Copyright (c) 2006, 2007, 2008  Eric B. Weddington
   2:/usr/lib/avr/include/avr/power.h ****    Copyright (c) 2011 Frdric Nadeau
   3:/usr/lib/avr/include/avr/power.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/power.h **** 
   5:/usr/lib/avr/include/avr/power.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/power.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/power.h **** 
   8:/usr/lib/avr/include/avr/power.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/power.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/power.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/avr/include/avr/power.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/avr/include/avr/power.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/avr/include/avr/power.h ****      distribution.
  14:/usr/lib/avr/include/avr/power.h ****    * Neither the name of the copyright holders nor the names of
  15:/usr/lib/avr/include/avr/power.h ****      contributors may be used to endorse or promote products derived
  16:/usr/lib/avr/include/avr/power.h ****      from this software without specific prior written permission.
  17:/usr/lib/avr/include/avr/power.h **** 
  18:/usr/lib/avr/include/avr/power.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  19:/usr/lib/avr/include/avr/power.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  20:/usr/lib/avr/include/avr/power.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  21:/usr/lib/avr/include/avr/power.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  22:/usr/lib/avr/include/avr/power.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  23:/usr/lib/avr/include/avr/power.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  24:/usr/lib/avr/include/avr/power.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  25:/usr/lib/avr/include/avr/power.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  26:/usr/lib/avr/include/avr/power.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  27:/usr/lib/avr/include/avr/power.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  28:/usr/lib/avr/include/avr/power.h ****   POSSIBILITY OF SUCH DAMAGE. */
  29:/usr/lib/avr/include/avr/power.h **** 
  30:/usr/lib/avr/include/avr/power.h **** /* $Id$ */
  31:/usr/lib/avr/include/avr/power.h **** 
  32:/usr/lib/avr/include/avr/power.h **** #ifndef _AVR_POWER_H_
  33:/usr/lib/avr/include/avr/power.h **** #define _AVR_POWER_H_   1
  34:/usr/lib/avr/include/avr/power.h **** 
  35:/usr/lib/avr/include/avr/power.h **** #include <avr/io.h>
  36:/usr/lib/avr/include/avr/power.h **** #include <stdint.h>
  37:/usr/lib/avr/include/avr/power.h **** 
  38:/usr/lib/avr/include/avr/power.h **** /** \file */
  39:/usr/lib/avr/include/avr/power.h **** /** \defgroup avr_power <avr/power.h>: Power Reduction Management
  40:/usr/lib/avr/include/avr/power.h **** 
  41:/usr/lib/avr/include/avr/power.h **** \code #include <avr/power.h>\endcode
  42:/usr/lib/avr/include/avr/power.h **** 
  43:/usr/lib/avr/include/avr/power.h **** Many AVRs contain a Power Reduction Register (PRR) or Registers (PRRx) that 
  44:/usr/lib/avr/include/avr/power.h **** allow you to reduce power consumption by disabling or enabling various on-board 
  45:/usr/lib/avr/include/avr/power.h **** peripherals as needed. Some devices have the XTAL Divide Control Register
  46:/usr/lib/avr/include/avr/power.h **** (XDIV) which offer similar functionality as System Clock Prescale
  47:/usr/lib/avr/include/avr/power.h **** Register (CLKPR).
  48:/usr/lib/avr/include/avr/power.h **** 
  49:/usr/lib/avr/include/avr/power.h **** There are many macros in this header file that provide an easy interface
  50:/usr/lib/avr/include/avr/power.h **** to enable or disable on-board peripherals to reduce power. See the table below.
  51:/usr/lib/avr/include/avr/power.h **** 
  52:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices have a Power Reduction Register (for example
  53:/usr/lib/avr/include/avr/power.h **** the ATmega8). On those devices without a Power Reduction Register, the
  54:/usr/lib/avr/include/avr/power.h **** power reduction macros are not available..
  55:/usr/lib/avr/include/avr/power.h **** 
  56:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices contain the same peripherals (for example, the LCD
  57:/usr/lib/avr/include/avr/power.h **** interface), or they will be named differently (for example, USART and 
  58:/usr/lib/avr/include/avr/power.h **** USART0). Please consult your device's datasheet, or the header file, to 
  59:/usr/lib/avr/include/avr/power.h **** find out which macros are applicable to your device.
  60:/usr/lib/avr/include/avr/power.h **** 
  61:/usr/lib/avr/include/avr/power.h **** \note For device using the XTAL Divide Control Register (XDIV), when prescaler
  62:/usr/lib/avr/include/avr/power.h **** is used, Timer/Counter0 can only be used in asynchronous mode. Keep in mind
  63:/usr/lib/avr/include/avr/power.h **** that Timer/Counter0 source shall be less than th of peripheral clock.
  64:/usr/lib/avr/include/avr/power.h **** Therefore, when using a typical 32.768 kHz crystal, one shall not scale
  65:/usr/lib/avr/include/avr/power.h **** the clock below 131.072 kHz.
  66:/usr/lib/avr/include/avr/power.h **** 
  67:/usr/lib/avr/include/avr/power.h **** */
  68:/usr/lib/avr/include/avr/power.h **** 
  69:/usr/lib/avr/include/avr/power.h **** 
  70:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
  71:/usr/lib/avr/include/avr/power.h **** 
  72:/usr/lib/avr/include/avr/power.h **** \anchor avr_powermacros
  73:/usr/lib/avr/include/avr/power.h **** <small>
  74:/usr/lib/avr/include/avr/power.h **** <center>
  75:/usr/lib/avr/include/avr/power.h **** <table border="3">
  76:/usr/lib/avr/include/avr/power.h ****   <tr>
  77:/usr/lib/avr/include/avr/power.h ****     <td width="10%"><strong>Power Macro</strong></td>
  78:/usr/lib/avr/include/avr/power.h ****     <td width="15%"><strong>Description</strong></td>
  79:/usr/lib/avr/include/avr/power.h ****   </tr>
  80:/usr/lib/avr/include/avr/power.h **** 
  81:/usr/lib/avr/include/avr/power.h ****   <tr>
  82:/usr/lib/avr/include/avr/power.h ****     <td>power_aca_disable()</td>
  83:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Analog Comparator on PortA.</td>
  84:/usr/lib/avr/include/avr/power.h ****   </tr>
  85:/usr/lib/avr/include/avr/power.h **** 
  86:/usr/lib/avr/include/avr/power.h ****   <tr>
  87:/usr/lib/avr/include/avr/power.h ****     <td>power_aca_enable()</td>
  88:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Analog Comparator on PortA.</td>
  89:/usr/lib/avr/include/avr/power.h ****   </tr>
  90:/usr/lib/avr/include/avr/power.h **** 
  91:/usr/lib/avr/include/avr/power.h ****   <tr>
  92:/usr/lib/avr/include/avr/power.h ****     <td>power_adc_enable()</td>
  93:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Analog to Digital Converter module.</td>
  94:/usr/lib/avr/include/avr/power.h ****   </tr>
  95:/usr/lib/avr/include/avr/power.h **** 
  96:/usr/lib/avr/include/avr/power.h ****   <tr>
  97:/usr/lib/avr/include/avr/power.h ****     <td>power_adc_disable()</td>
  98:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Analog to Digital Converter module.</td>
  99:/usr/lib/avr/include/avr/power.h ****   </tr>
 100:/usr/lib/avr/include/avr/power.h **** 
 101:/usr/lib/avr/include/avr/power.h ****   <tr>
 102:/usr/lib/avr/include/avr/power.h ****     <td>power_adca_disable()</td>
 103:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Analog to Digital Converter module on PortA</td>
 104:/usr/lib/avr/include/avr/power.h ****   </tr>
 105:/usr/lib/avr/include/avr/power.h **** 
 106:/usr/lib/avr/include/avr/power.h ****   <tr>
 107:/usr/lib/avr/include/avr/power.h ****     <td>power_adca_enable()</td>
 108:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Analog to Digital Converter module on PortA</td>
 109:/usr/lib/avr/include/avr/power.h ****   </tr>
 110:/usr/lib/avr/include/avr/power.h **** 
 111:/usr/lib/avr/include/avr/power.h ****   <tr>
 112:/usr/lib/avr/include/avr/power.h ****     <td>power_evsys_disable()</td>
 113:/usr/lib/avr/include/avr/power.h ****     <td>Disable the EVSYS module</td>
 114:/usr/lib/avr/include/avr/power.h ****   </tr>
 115:/usr/lib/avr/include/avr/power.h **** 
 116:/usr/lib/avr/include/avr/power.h ****   <tr>
 117:/usr/lib/avr/include/avr/power.h ****     <td>power_evsys_enable()</td>
 118:/usr/lib/avr/include/avr/power.h ****     <td>Enable the EVSYS module</td>
 119:/usr/lib/avr/include/avr/power.h ****   </tr>
 120:/usr/lib/avr/include/avr/power.h **** 
 121:/usr/lib/avr/include/avr/power.h ****   <tr>
 122:/usr/lib/avr/include/avr/power.h ****     <td>power_hiresc_disable()</td>
 123:/usr/lib/avr/include/avr/power.h ****     <td>Disable the HIRES module on PortC</td>
 124:/usr/lib/avr/include/avr/power.h ****   </tr>
 125:/usr/lib/avr/include/avr/power.h **** 
 126:/usr/lib/avr/include/avr/power.h ****   <tr>
 127:/usr/lib/avr/include/avr/power.h ****     <td>power_hiresc_enable()</td>
 128:/usr/lib/avr/include/avr/power.h ****     <td>Enable the HIRES module on PortC</td>
 129:/usr/lib/avr/include/avr/power.h ****   </tr>
 130:/usr/lib/avr/include/avr/power.h **** 
 131:/usr/lib/avr/include/avr/power.h ****    <tr>
 132:/usr/lib/avr/include/avr/power.h ****     <td>power_lcd_enable()</td>
 133:/usr/lib/avr/include/avr/power.h ****     <td>Enable the LCD module.</td>
 134:/usr/lib/avr/include/avr/power.h ****   </tr>
 135:/usr/lib/avr/include/avr/power.h **** 
 136:/usr/lib/avr/include/avr/power.h ****   <tr>
 137:/usr/lib/avr/include/avr/power.h ****     <td>power_lcd_disable().</td>
 138:/usr/lib/avr/include/avr/power.h ****     <td>Disable the LCD module.</td>
 139:/usr/lib/avr/include/avr/power.h ****   </tr>
 140:/usr/lib/avr/include/avr/power.h **** 
 141:/usr/lib/avr/include/avr/power.h ****   <tr>
 142:/usr/lib/avr/include/avr/power.h ****     <td>power_pga_enable()</td>
 143:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Programmable Gain Amplifier module.</td>
 144:/usr/lib/avr/include/avr/power.h ****   </tr>
 145:/usr/lib/avr/include/avr/power.h **** 
 146:/usr/lib/avr/include/avr/power.h ****   <tr>
 147:/usr/lib/avr/include/avr/power.h ****     <td>power_pga_disable()</td>
 148:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Programmable Gain Amplifier module.</td>
 149:/usr/lib/avr/include/avr/power.h ****   </tr>
 150:/usr/lib/avr/include/avr/power.h **** 
 151:/usr/lib/avr/include/avr/power.h ****   <tr>
 152:/usr/lib/avr/include/avr/power.h ****     <td>power_pscr_enable()</td>
 153:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Reduced Power Stage Controller module.</td>
 154:/usr/lib/avr/include/avr/power.h ****   </tr>
 155:/usr/lib/avr/include/avr/power.h **** 
 156:/usr/lib/avr/include/avr/power.h ****   <tr>
 157:/usr/lib/avr/include/avr/power.h ****     <td>power_pscr_disable()</td>
 158:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Reduced Power Stage Controller module.</td>
 159:/usr/lib/avr/include/avr/power.h ****   </tr>
 160:/usr/lib/avr/include/avr/power.h **** 
 161:/usr/lib/avr/include/avr/power.h ****   <tr>
 162:/usr/lib/avr/include/avr/power.h ****     <td>power_psc0_enable()</td>
 163:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 0 module.</td>
 164:/usr/lib/avr/include/avr/power.h ****   </tr>
 165:/usr/lib/avr/include/avr/power.h **** 
 166:/usr/lib/avr/include/avr/power.h ****   <tr>
 167:/usr/lib/avr/include/avr/power.h ****     <td>power_psc0_disable()</td>
 168:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 0 module.</td>
 169:/usr/lib/avr/include/avr/power.h ****   </tr>
 170:/usr/lib/avr/include/avr/power.h **** 
 171:/usr/lib/avr/include/avr/power.h ****   <tr>
 172:/usr/lib/avr/include/avr/power.h ****     <td>power_psc1_enable()</td>
 173:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 1 module.</td>
 174:/usr/lib/avr/include/avr/power.h ****   </tr>
 175:/usr/lib/avr/include/avr/power.h **** 
 176:/usr/lib/avr/include/avr/power.h ****   <tr>
 177:/usr/lib/avr/include/avr/power.h ****     <td>power_psc1_disable()</td>
 178:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 1 module.</td>
 179:/usr/lib/avr/include/avr/power.h ****   </tr>
 180:/usr/lib/avr/include/avr/power.h **** 
 181:/usr/lib/avr/include/avr/power.h ****   <tr>
 182:/usr/lib/avr/include/avr/power.h ****     <td>power_psc2_enable()</td>
 183:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 2 module.</td>
 184:/usr/lib/avr/include/avr/power.h ****   </tr>
 185:/usr/lib/avr/include/avr/power.h **** 
 186:/usr/lib/avr/include/avr/power.h ****   <tr>
 187:/usr/lib/avr/include/avr/power.h ****     <td>power_psc2_disable()</td>
 188:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 2 module.</td>
 189:/usr/lib/avr/include/avr/power.h ****   </tr>
 190:/usr/lib/avr/include/avr/power.h **** 
 191:/usr/lib/avr/include/avr/power.h ****   <tr>
 192:/usr/lib/avr/include/avr/power.h ****     <td>power_ram0_enable()</td>
 193:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 0 .</td>
 194:/usr/lib/avr/include/avr/power.h ****   </tr>
 195:/usr/lib/avr/include/avr/power.h **** 
 196:/usr/lib/avr/include/avr/power.h ****   <tr>
 197:/usr/lib/avr/include/avr/power.h ****     <td>power_ram0_disable()</td>
 198:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 0. </td>
 199:/usr/lib/avr/include/avr/power.h ****   </tr>
 200:/usr/lib/avr/include/avr/power.h **** 
 201:/usr/lib/avr/include/avr/power.h ****   <tr>
 202:/usr/lib/avr/include/avr/power.h ****     <td>power_ram1_enable()</td>
 203:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 1 .</td>
 204:/usr/lib/avr/include/avr/power.h ****   </tr>
 205:/usr/lib/avr/include/avr/power.h **** 
 206:/usr/lib/avr/include/avr/power.h ****   <tr>
 207:/usr/lib/avr/include/avr/power.h ****     <td>power_ram1_disable()</td>
 208:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 1. </td>
 209:/usr/lib/avr/include/avr/power.h ****   </tr>
 210:/usr/lib/avr/include/avr/power.h **** 
 211:/usr/lib/avr/include/avr/power.h ****   <tr>
 212:/usr/lib/avr/include/avr/power.h ****     <td>power_ram2_enable()</td>
 213:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 2 .</td>
 214:/usr/lib/avr/include/avr/power.h ****   </tr>
 215:/usr/lib/avr/include/avr/power.h **** 
 216:/usr/lib/avr/include/avr/power.h ****   <tr>
 217:/usr/lib/avr/include/avr/power.h ****     <td>power_ram2_disable()</td>
 218:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 2. </td>
 219:/usr/lib/avr/include/avr/power.h ****   </tr>
 220:/usr/lib/avr/include/avr/power.h **** 
 221:/usr/lib/avr/include/avr/power.h ****   <tr>
 222:/usr/lib/avr/include/avr/power.h ****     <td>power_ram3_enable()</td>
 223:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 3 .</td>
 224:/usr/lib/avr/include/avr/power.h ****   </tr>
 225:/usr/lib/avr/include/avr/power.h **** 
 226:/usr/lib/avr/include/avr/power.h ****   <tr>
 227:/usr/lib/avr/include/avr/power.h ****     <td>power_ram3_disable()</td>
 228:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 3. </td>
 229:/usr/lib/avr/include/avr/power.h ****   </tr>
 230:/usr/lib/avr/include/avr/power.h **** 
 231:/usr/lib/avr/include/avr/power.h ****   <tr>
 232:/usr/lib/avr/include/avr/power.h ****     <td>power_rtc_disable()</td>
 233:/usr/lib/avr/include/avr/power.h ****     <td>Disable the RTC module</td>
 234:/usr/lib/avr/include/avr/power.h ****   </tr>
 235:/usr/lib/avr/include/avr/power.h **** 
 236:/usr/lib/avr/include/avr/power.h ****   <tr>
 237:/usr/lib/avr/include/avr/power.h ****     <td>power_rtc_enable()</td>
 238:/usr/lib/avr/include/avr/power.h ****     <td>Enable the RTC module</td>
 239:/usr/lib/avr/include/avr/power.h ****   </tr>
 240:/usr/lib/avr/include/avr/power.h **** 
 241:/usr/lib/avr/include/avr/power.h ****   <tr>
 242:/usr/lib/avr/include/avr/power.h ****     <td>power_spi_enable()</td>
 243:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Serial Peripheral Interface module.</td>
 244:/usr/lib/avr/include/avr/power.h ****   </tr>
 245:/usr/lib/avr/include/avr/power.h **** 
 246:/usr/lib/avr/include/avr/power.h ****   <tr>
 247:/usr/lib/avr/include/avr/power.h ****     <td>power_spi_disable()</td>
 248:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Serial Peripheral Interface module.</td>
 249:/usr/lib/avr/include/avr/power.h ****   </tr>
 250:/usr/lib/avr/include/avr/power.h **** 
 251:/usr/lib/avr/include/avr/power.h ****   <tr>
 252:/usr/lib/avr/include/avr/power.h ****     <td>power_spic_disable()</td>
 253:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SPI module on PortC</td>
 254:/usr/lib/avr/include/avr/power.h ****   </tr>
 255:/usr/lib/avr/include/avr/power.h **** 
 256:/usr/lib/avr/include/avr/power.h ****   <tr>
 257:/usr/lib/avr/include/avr/power.h ****     <td>power_spic_enable()</td>
 258:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SPI module on PortC</td>
 259:/usr/lib/avr/include/avr/power.h ****   </tr>
 260:/usr/lib/avr/include/avr/power.h **** 
 261:/usr/lib/avr/include/avr/power.h ****   <tr>
 262:/usr/lib/avr/include/avr/power.h ****     <td>power_spid_disable()</td>
 263:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SPI module on PortD</td>
 264:/usr/lib/avr/include/avr/power.h ****   </tr>
 265:/usr/lib/avr/include/avr/power.h **** 
 266:/usr/lib/avr/include/avr/power.h ****   <tr>
 267:/usr/lib/avr/include/avr/power.h ****     <td>power_spid_enable()</td>
 268:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SPI module on PortD</td>
 269:/usr/lib/avr/include/avr/power.h ****   </tr>
 270:/usr/lib/avr/include/avr/power.h **** 
 271:/usr/lib/avr/include/avr/power.h ****   <tr>
 272:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0c_disable()</td>
 273:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortC</td>
 274:/usr/lib/avr/include/avr/power.h ****   </tr>
 275:/usr/lib/avr/include/avr/power.h **** 
 276:/usr/lib/avr/include/avr/power.h ****   <tr>
 277:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0c_enable()</td>
 278:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortC</td>
 279:/usr/lib/avr/include/avr/power.h ****   </tr>
 280:/usr/lib/avr/include/avr/power.h **** 
 281:/usr/lib/avr/include/avr/power.h ****   <tr>
 282:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0d_disable()</td>
 283:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortD</td>
 284:/usr/lib/avr/include/avr/power.h ****   </tr>
 285:/usr/lib/avr/include/avr/power.h **** 
 286:/usr/lib/avr/include/avr/power.h ****   <tr>
 287:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0d_enable()</td>
 288:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortD</td>
 289:/usr/lib/avr/include/avr/power.h ****   </tr>
 290:/usr/lib/avr/include/avr/power.h **** 
 291:/usr/lib/avr/include/avr/power.h ****   <tr>
 292:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0e_disable()</td>
 293:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortE</td>
 294:/usr/lib/avr/include/avr/power.h ****   </tr>
 295:/usr/lib/avr/include/avr/power.h **** 
 296:/usr/lib/avr/include/avr/power.h ****   <tr>
 297:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0e_enable()</td>
 298:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortE</td>
 299:/usr/lib/avr/include/avr/power.h ****   </tr>
 300:/usr/lib/avr/include/avr/power.h **** 
 301:/usr/lib/avr/include/avr/power.h ****   <tr>
 302:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0f_disable()</td>
 303:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortF</td>
 304:/usr/lib/avr/include/avr/power.h ****   </tr>
 305:/usr/lib/avr/include/avr/power.h **** 
 306:/usr/lib/avr/include/avr/power.h ****   <tr>
 307:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0f_enable()</td>
 308:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortF</td>
 309:/usr/lib/avr/include/avr/power.h ****   </tr>
 310:/usr/lib/avr/include/avr/power.h **** 
 311:/usr/lib/avr/include/avr/power.h ****   <tr>
 312:/usr/lib/avr/include/avr/power.h ****     <td>power_tc1c_disable()</td>
 313:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC1 module on PortC</td>
 314:/usr/lib/avr/include/avr/power.h ****   </tr>
 315:/usr/lib/avr/include/avr/power.h **** 
 316:/usr/lib/avr/include/avr/power.h ****   <tr>
 317:/usr/lib/avr/include/avr/power.h ****     <td>power_tc1c_enable()</td>
 318:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC1 module on PortC</td>
 319:/usr/lib/avr/include/avr/power.h ****   </tr>
 320:/usr/lib/avr/include/avr/power.h **** 
 321:/usr/lib/avr/include/avr/power.h ****   <tr>
 322:/usr/lib/avr/include/avr/power.h ****     <td>power_twic_disable()</td>
 323:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module on PortC</td>
 324:/usr/lib/avr/include/avr/power.h ****   </tr>
 325:/usr/lib/avr/include/avr/power.h **** 
 326:/usr/lib/avr/include/avr/power.h ****   <tr>
 327:/usr/lib/avr/include/avr/power.h ****     <td>power_twic_enable()</td>
 328:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module on PortC</td>
 329:/usr/lib/avr/include/avr/power.h ****   </tr>
 330:/usr/lib/avr/include/avr/power.h **** 
 331:/usr/lib/avr/include/avr/power.h ****   <tr>
 332:/usr/lib/avr/include/avr/power.h ****     <td>power_twie_disable()</td>
 333:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module on PortE</td>
 334:/usr/lib/avr/include/avr/power.h ****   </tr>
 335:/usr/lib/avr/include/avr/power.h **** 
 336:/usr/lib/avr/include/avr/power.h ****   <tr>
 337:/usr/lib/avr/include/avr/power.h ****     <td>power_twie_enable()</td>
 338:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module on PortE</td>
 339:/usr/lib/avr/include/avr/power.h ****   </tr>
 340:/usr/lib/avr/include/avr/power.h **** 
 341:/usr/lib/avr/include/avr/power.h ****   <tr>
 342:/usr/lib/avr/include/avr/power.h ****     <td>power_timer0_enable()</td>
 343:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 0 module.</td>
 344:/usr/lib/avr/include/avr/power.h ****   </tr>
 345:/usr/lib/avr/include/avr/power.h **** 
 346:/usr/lib/avr/include/avr/power.h ****   <tr>
 347:/usr/lib/avr/include/avr/power.h ****     <td>power_timer0_disable()</td>
 348:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 0 module.</td>
 349:/usr/lib/avr/include/avr/power.h ****   </tr>
 350:/usr/lib/avr/include/avr/power.h **** 
 351:/usr/lib/avr/include/avr/power.h ****   <tr>
 352:/usr/lib/avr/include/avr/power.h ****     <td>power_timer1_enable()</td>
 353:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 1 module.</td>
 354:/usr/lib/avr/include/avr/power.h ****   </tr>
 355:/usr/lib/avr/include/avr/power.h **** 
 356:/usr/lib/avr/include/avr/power.h ****   <tr>
 357:/usr/lib/avr/include/avr/power.h ****     <td>power_timer1_disable()</td>
 358:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 1 module.</td>
 359:/usr/lib/avr/include/avr/power.h ****   </tr>
 360:/usr/lib/avr/include/avr/power.h **** 
 361:/usr/lib/avr/include/avr/power.h ****   <tr>
 362:/usr/lib/avr/include/avr/power.h ****     <td>power_timer2_enable()</td>
 363:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 2 module.</td>
 364:/usr/lib/avr/include/avr/power.h ****   </tr>
 365:/usr/lib/avr/include/avr/power.h **** 
 366:/usr/lib/avr/include/avr/power.h ****   <tr>
 367:/usr/lib/avr/include/avr/power.h ****     <td>power_timer2_disable()</td>
 368:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 2 module.</td>
 369:/usr/lib/avr/include/avr/power.h ****   </tr>
 370:/usr/lib/avr/include/avr/power.h **** 
 371:/usr/lib/avr/include/avr/power.h ****   <tr>
 372:/usr/lib/avr/include/avr/power.h ****     <td>power_timer3_enable()</td>
 373:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 3 module.</td>
 374:/usr/lib/avr/include/avr/power.h ****   </tr>
 375:/usr/lib/avr/include/avr/power.h **** 
 376:/usr/lib/avr/include/avr/power.h ****   <tr>
 377:/usr/lib/avr/include/avr/power.h ****     <td>power_timer3_disable()</td>
 378:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 3 module.</td>
 379:/usr/lib/avr/include/avr/power.h ****   </tr>
 380:/usr/lib/avr/include/avr/power.h **** 
 381:/usr/lib/avr/include/avr/power.h ****   <tr>
 382:/usr/lib/avr/include/avr/power.h ****     <td>power_timer4_enable()</td>
 383:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 4 module.</td>
 384:/usr/lib/avr/include/avr/power.h ****   </tr>
 385:/usr/lib/avr/include/avr/power.h **** 
 386:/usr/lib/avr/include/avr/power.h ****   <tr>
 387:/usr/lib/avr/include/avr/power.h ****     <td>power_timer4_disable()</td>
 388:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 4 module.</td>
 389:/usr/lib/avr/include/avr/power.h ****   </tr>
 390:/usr/lib/avr/include/avr/power.h **** 
 391:/usr/lib/avr/include/avr/power.h ****   <tr>
 392:/usr/lib/avr/include/avr/power.h ****     <td>power_timer5_enable()</td>
 393:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 5 module.</td>
 394:/usr/lib/avr/include/avr/power.h ****   </tr>
 395:/usr/lib/avr/include/avr/power.h **** 
 396:/usr/lib/avr/include/avr/power.h ****   <tr>
 397:/usr/lib/avr/include/avr/power.h ****     <td>power_timer5_disable()</td>
 398:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 5 module.</td>
 399:/usr/lib/avr/include/avr/power.h ****   </tr>
 400:/usr/lib/avr/include/avr/power.h **** 
 401:/usr/lib/avr/include/avr/power.h ****   <tr>
 402:/usr/lib/avr/include/avr/power.h ****     <td>power_twi_enable()</td>
 403:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module.</td>
 404:/usr/lib/avr/include/avr/power.h ****   </tr>
 405:/usr/lib/avr/include/avr/power.h **** 
 406:/usr/lib/avr/include/avr/power.h ****   <tr>
 407:/usr/lib/avr/include/avr/power.h ****     <td>power_twi_disable()</td>
 408:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module.</td>
 409:/usr/lib/avr/include/avr/power.h ****   </tr>
 410:/usr/lib/avr/include/avr/power.h **** 
 411:/usr/lib/avr/include/avr/power.h ****   <tr>
 412:/usr/lib/avr/include/avr/power.h ****     <td>power_usart_enable()</td>
 413:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART module.</td>
 414:/usr/lib/avr/include/avr/power.h ****   </tr>
 415:/usr/lib/avr/include/avr/power.h **** 
 416:/usr/lib/avr/include/avr/power.h ****   <tr>
 417:/usr/lib/avr/include/avr/power.h ****     <td>power_usart_disable()</td>
 418:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART module.</td>
 419:/usr/lib/avr/include/avr/power.h ****   </tr>
 420:/usr/lib/avr/include/avr/power.h **** 
 421:/usr/lib/avr/include/avr/power.h ****   <tr>
 422:/usr/lib/avr/include/avr/power.h ****     <td>power_usart0_enable()</td>
 423:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 0 module.</td>
 424:/usr/lib/avr/include/avr/power.h ****   </tr>
 425:/usr/lib/avr/include/avr/power.h **** 
 426:/usr/lib/avr/include/avr/power.h ****   <tr>
 427:/usr/lib/avr/include/avr/power.h ****     <td>power_usart0_disable()</td>
 428:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 0 module.</td>
 429:/usr/lib/avr/include/avr/power.h ****   </tr>
 430:/usr/lib/avr/include/avr/power.h **** 
 431:/usr/lib/avr/include/avr/power.h ****   <tr>
 432:/usr/lib/avr/include/avr/power.h ****     <td>power_usart1_enable()</td>
 433:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 1 module.</td>
 434:/usr/lib/avr/include/avr/power.h ****   </tr>
 435:/usr/lib/avr/include/avr/power.h **** 
 436:/usr/lib/avr/include/avr/power.h ****   <tr>
 437:/usr/lib/avr/include/avr/power.h ****     <td>power_usart1_disable()</td>
 438:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 1 module.</td>
 439:/usr/lib/avr/include/avr/power.h ****   </tr>
 440:/usr/lib/avr/include/avr/power.h **** 
 441:/usr/lib/avr/include/avr/power.h ****   <tr>
 442:/usr/lib/avr/include/avr/power.h ****     <td>power_usart2_enable()</td>
 443:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 2 module.</td>
 444:/usr/lib/avr/include/avr/power.h ****   </tr>
 445:/usr/lib/avr/include/avr/power.h **** 
 446:/usr/lib/avr/include/avr/power.h ****   <tr>
 447:/usr/lib/avr/include/avr/power.h ****     <td>power_usart2_disable()</td>
 448:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 2 module.</td>
 449:/usr/lib/avr/include/avr/power.h ****   </tr>
 450:/usr/lib/avr/include/avr/power.h **** 
 451:/usr/lib/avr/include/avr/power.h ****   <tr>
 452:/usr/lib/avr/include/avr/power.h ****     <td>power_usart3_enable()</td>
 453:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 3 module.</td>
 454:/usr/lib/avr/include/avr/power.h ****   </tr>
 455:/usr/lib/avr/include/avr/power.h **** 
 456:/usr/lib/avr/include/avr/power.h ****   <tr>
 457:/usr/lib/avr/include/avr/power.h ****     <td>power_usart3_disable()</td>
 458:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 3 module.</td>
 459:/usr/lib/avr/include/avr/power.h ****   </tr>
 460:/usr/lib/avr/include/avr/power.h **** 
 461:/usr/lib/avr/include/avr/power.h ****   <tr>
 462:/usr/lib/avr/include/avr/power.h ****     <td>power_usartc0_disable()</td>
 463:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortC</td>
 464:/usr/lib/avr/include/avr/power.h ****   </tr>
 465:/usr/lib/avr/include/avr/power.h **** 
 466:/usr/lib/avr/include/avr/power.h ****   <tr>
 467:/usr/lib/avr/include/avr/power.h ****     <td>power_usartc0_enable()</td>
 468:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortC</td>
 469:/usr/lib/avr/include/avr/power.h ****   </tr>
 470:/usr/lib/avr/include/avr/power.h **** 
 471:/usr/lib/avr/include/avr/power.h ****   <tr>
 472:/usr/lib/avr/include/avr/power.h ****     <td>power_usartd0_disable()</td>
 473:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortD</td>
 474:/usr/lib/avr/include/avr/power.h ****   </tr>
 475:/usr/lib/avr/include/avr/power.h **** 
 476:/usr/lib/avr/include/avr/power.h ****   <tr>
 477:/usr/lib/avr/include/avr/power.h ****     <td>power_usartd0_enable()</td>
 478:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortD</td>
 479:/usr/lib/avr/include/avr/power.h ****   </tr>
 480:/usr/lib/avr/include/avr/power.h **** 
 481:/usr/lib/avr/include/avr/power.h ****   <tr>
 482:/usr/lib/avr/include/avr/power.h ****     <td>power_usarte0_disable()</td>
 483:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortE</td>
 484:/usr/lib/avr/include/avr/power.h ****   </tr>
 485:/usr/lib/avr/include/avr/power.h **** 
 486:/usr/lib/avr/include/avr/power.h ****   <tr>
 487:/usr/lib/avr/include/avr/power.h ****     <td>power_usarte0_enable()</td>
 488:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortE</td>
 489:/usr/lib/avr/include/avr/power.h ****   </tr>
 490:/usr/lib/avr/include/avr/power.h **** 
 491:/usr/lib/avr/include/avr/power.h ****   <tr>
 492:/usr/lib/avr/include/avr/power.h ****     <td>power_usartf0_disable()</td>
 493:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortF</td>
 494:/usr/lib/avr/include/avr/power.h ****   </tr>
 495:/usr/lib/avr/include/avr/power.h **** 
 496:/usr/lib/avr/include/avr/power.h ****   <tr>
 497:/usr/lib/avr/include/avr/power.h ****     <td>power_usartf0_enable()</td>
 498:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortF</td>
 499:/usr/lib/avr/include/avr/power.h ****   </tr>
 500:/usr/lib/avr/include/avr/power.h **** 
 501:/usr/lib/avr/include/avr/power.h ****   <tr>
 502:/usr/lib/avr/include/avr/power.h ****     <td>power_usb_enable()</td>
 503:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USB module.</td>
 504:/usr/lib/avr/include/avr/power.h ****   </tr>
 505:/usr/lib/avr/include/avr/power.h **** 
 506:/usr/lib/avr/include/avr/power.h ****   <tr>
 507:/usr/lib/avr/include/avr/power.h ****     <td>power_usb_disable()</td>
 508:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USB module.</td>
 509:/usr/lib/avr/include/avr/power.h ****   </tr>
 510:/usr/lib/avr/include/avr/power.h **** 
 511:/usr/lib/avr/include/avr/power.h ****   <tr>
 512:/usr/lib/avr/include/avr/power.h ****     <td>power_usi_enable()</td>
 513:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Universal Serial Interface module.</td>
 514:/usr/lib/avr/include/avr/power.h ****   </tr>
 515:/usr/lib/avr/include/avr/power.h **** 
 516:/usr/lib/avr/include/avr/power.h ****   <tr>
 517:/usr/lib/avr/include/avr/power.h ****     <td>power_usi_disable()</td>
 518:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Universal Serial Interface module.</td>
 519:/usr/lib/avr/include/avr/power.h ****   </tr>
 520:/usr/lib/avr/include/avr/power.h **** 
 521:/usr/lib/avr/include/avr/power.h ****   <tr>
 522:/usr/lib/avr/include/avr/power.h ****     <td>power_vadc_enable()</td>
 523:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Voltage ADC module.</td>
 524:/usr/lib/avr/include/avr/power.h ****   </tr>
 525:/usr/lib/avr/include/avr/power.h **** 
 526:/usr/lib/avr/include/avr/power.h ****   <tr>
 527:/usr/lib/avr/include/avr/power.h ****     <td>power_vadc_disable()</td>
 528:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Voltage ADC module.</td>
 529:/usr/lib/avr/include/avr/power.h ****   </tr>
 530:/usr/lib/avr/include/avr/power.h **** 
 531:/usr/lib/avr/include/avr/power.h ****   <tr>
 532:/usr/lib/avr/include/avr/power.h ****     <td>power_all_enable()</td>
 533:/usr/lib/avr/include/avr/power.h ****     <td>Enable all modules.</td>
 534:/usr/lib/avr/include/avr/power.h ****   </tr>
 535:/usr/lib/avr/include/avr/power.h **** 
 536:/usr/lib/avr/include/avr/power.h ****   <tr>
 537:/usr/lib/avr/include/avr/power.h ****     <td>power_all_disable()</td>
 538:/usr/lib/avr/include/avr/power.h ****     <td>Disable all modules.</td>
 539:/usr/lib/avr/include/avr/power.h ****   </tr>
 540:/usr/lib/avr/include/avr/power.h **** </table>
 541:/usr/lib/avr/include/avr/power.h **** </center>
 542:/usr/lib/avr/include/avr/power.h **** </small>
 543:/usr/lib/avr/include/avr/power.h **** 
 544:/usr/lib/avr/include/avr/power.h **** @} */
 545:/usr/lib/avr/include/avr/power.h **** 
 546:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRADC)
 547:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR &= (uint8_t)~(1 << PRADC))
 548:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR |= (uint8_t)(1 << PRADC))
 549:/usr/lib/avr/include/avr/power.h **** #endif
 550:/usr/lib/avr/include/avr/power.h **** 
 551:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRCAN)
 552:/usr/lib/avr/include/avr/power.h **** #define power_can_enable()      (PRR &= (uint8_t)~(1 << PRCAN))
 553:/usr/lib/avr/include/avr/power.h **** #define power_can_disable()     (PRR |= (uint8_t)(1 << PRCAN))
 554:/usr/lib/avr/include/avr/power.h **** #endif
 555:/usr/lib/avr/include/avr/power.h **** 
 556:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRLCD)
 557:/usr/lib/avr/include/avr/power.h **** #define power_lcd_enable()      (PRR &= (uint8_t)~(1 << PRLCD))
 558:/usr/lib/avr/include/avr/power.h **** #define power_lcd_disable()     (PRR |= (uint8_t)(1 << PRLCD))
 559:/usr/lib/avr/include/avr/power.h **** #endif
 560:/usr/lib/avr/include/avr/power.h **** 
 561:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRLIN)
 562:/usr/lib/avr/include/avr/power.h **** #define power_lin_enable()      (PRR &= (uint8_t)~(1 << PRLIN))
 563:/usr/lib/avr/include/avr/power.h **** #define power_lin_disable()     (PRR |= (uint8_t)(1 << PRLIN))
 564:/usr/lib/avr/include/avr/power.h **** #endif
 565:/usr/lib/avr/include/avr/power.h **** 
 566:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC)
 567:/usr/lib/avr/include/avr/power.h **** #define power_psc_enable()      (PRR &= (uint8_t)~(1 << PRPSC))
 568:/usr/lib/avr/include/avr/power.h **** #define power_psc_disable()     (PRR |= (uint8_t)(1 << PRPSC))
 569:/usr/lib/avr/include/avr/power.h **** #endif
 570:/usr/lib/avr/include/avr/power.h **** 
 571:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC0)
 572:/usr/lib/avr/include/avr/power.h **** #define power_psc0_enable()     (PRR &= (uint8_t)~(1 << PRPSC0))
 573:/usr/lib/avr/include/avr/power.h **** #define power_psc0_disable()    (PRR |= (uint8_t)(1 << PRPSC0))
 574:/usr/lib/avr/include/avr/power.h **** #endif
 575:/usr/lib/avr/include/avr/power.h **** 
 576:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC1)
 577:/usr/lib/avr/include/avr/power.h **** #define power_psc1_enable()     (PRR &= (uint8_t)~(1 << PRPSC1))
 578:/usr/lib/avr/include/avr/power.h **** #define power_psc1_disable()    (PRR |= (uint8_t)(1 << PRPSC1))
 579:/usr/lib/avr/include/avr/power.h **** #endif
 580:/usr/lib/avr/include/avr/power.h **** 
 581:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC2)
 582:/usr/lib/avr/include/avr/power.h **** #define power_psc2_enable()     (PRR &= (uint8_t)~(1 << PRPSC2))
 583:/usr/lib/avr/include/avr/power.h **** #define power_psc2_disable()    (PRR |= (uint8_t)(1 << PRPSC2))
 584:/usr/lib/avr/include/avr/power.h **** #endif
 585:/usr/lib/avr/include/avr/power.h **** 
 586:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRSCR)
 587:/usr/lib/avr/include/avr/power.h **** #define power_pscr_enable()     (PRR &= (uint8_t)~(1 << PRPSCR))
 588:/usr/lib/avr/include/avr/power.h **** #define power_pscr_disable()    (PRR |= (uint8_t)(1 << PRPSCR))
 589:/usr/lib/avr/include/avr/power.h **** #endif
 590:/usr/lib/avr/include/avr/power.h **** 
 591:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRSPI)
 592:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR &= (uint8_t)~(1 << PRSPI))
 593:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR |= (uint8_t)(1 << PRSPI))
 594:/usr/lib/avr/include/avr/power.h **** #endif
 595:/usr/lib/avr/include/avr/power.h **** 
 596:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM0)
 597:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR &= (uint8_t)~(1 << PRTIM0))
 598:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR |= (uint8_t)(1 << PRTIM0))
 599:/usr/lib/avr/include/avr/power.h **** #endif
 600:/usr/lib/avr/include/avr/power.h **** 
 601:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM1)
 602:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR &= (uint8_t)~(1 << PRTIM1))
 603:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR |= (uint8_t)(1 << PRTIM1))
 604:/usr/lib/avr/include/avr/power.h **** #endif
 605:/usr/lib/avr/include/avr/power.h **** 
 606:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM2)
 607:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()   (PRR &= (uint8_t)~(1 << PRTIM2))
 608:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()  (PRR |= (uint8_t)(1 << PRTIM2))
 609:/usr/lib/avr/include/avr/power.h **** #endif
 610:/usr/lib/avr/include/avr/power.h **** 
 611:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTWI)
 612:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()      (PRR &= (uint8_t)~(1 << PRTWI))
 613:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()     (PRR |= (uint8_t)(1 << PRTWI))
 614:/usr/lib/avr/include/avr/power.h **** #endif
 615:/usr/lib/avr/include/avr/power.h **** 
 616:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART)
 617:/usr/lib/avr/include/avr/power.h **** #define power_usart_enable()    (PRR &= (uint8_t)~(1 << PRUSART))
 618:/usr/lib/avr/include/avr/power.h **** #define power_usart_disable()   (PRR |= (uint8_t)(1 << PRUSART))
 619:/usr/lib/avr/include/avr/power.h **** #endif
 620:/usr/lib/avr/include/avr/power.h **** 
 621:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART0)
 622:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()   (PRR &= (uint8_t)~(1 << PRUSART0))
 623:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()  (PRR |= (uint8_t)(1 << PRUSART0))
 624:/usr/lib/avr/include/avr/power.h **** #endif
 625:/usr/lib/avr/include/avr/power.h **** 
 626:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART1)
 627:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()   (PRR &= (uint8_t)~(1 << PRUSART1))
 628:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()  (PRR |= (uint8_t)(1 << PRUSART1))
 629:/usr/lib/avr/include/avr/power.h **** #endif
 630:/usr/lib/avr/include/avr/power.h **** 
 631:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSI)
 632:/usr/lib/avr/include/avr/power.h **** #define power_usi_enable()      (PRR &= (uint8_t)~(1 << PRUSI))
 633:/usr/lib/avr/include/avr/power.h **** #define power_usi_disable()     (PRR |= (uint8_t)(1 << PRUSI))
 634:/usr/lib/avr/include/avr/power.h **** #endif
 635:/usr/lib/avr/include/avr/power.h **** 
 636:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRADC)
 637:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR0 &= (uint8_t)~(1 << PRADC))
 638:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR0 |= (uint8_t)(1 << PRADC))
 639:/usr/lib/avr/include/avr/power.h **** #endif
 640:/usr/lib/avr/include/avr/power.h **** 
 641:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRC0)
 642:/usr/lib/avr/include/avr/power.h **** #define power_clock_output_enable()     (PRR0 &= (uint8_t)~(1 << PRCO))
 643:/usr/lib/avr/include/avr/power.h **** #define power_clock_output_disable()    (PRR0 |= (uint8_t)(1 << PRCO))
 644:/usr/lib/avr/include/avr/power.h **** #endif
 645:/usr/lib/avr/include/avr/power.h **** 
 646:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRCRC)
 647:/usr/lib/avr/include/avr/power.h **** #define power_crc_enable()              (PRR0 &= (uint8_t)~(1 << PRCRC))
 648:/usr/lib/avr/include/avr/power.h **** #define power_crc_disable()             (PRR0 |= (uint8_t)(1 << PRCRC))
 649:/usr/lib/avr/include/avr/power.h **** #endif
 650:/usr/lib/avr/include/avr/power.h **** 
 651:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRCU)
 652:/usr/lib/avr/include/avr/power.h **** #define power_crypto_enable()           (PRR0 &= (uint8_t)~(1 << PRCU))
 653:/usr/lib/avr/include/avr/power.h **** #define power_crypto_disable()          (PRR0 |= (uint8_t)(1 << PRCU))
 654:/usr/lib/avr/include/avr/power.h **** #endif
 655:/usr/lib/avr/include/avr/power.h **** 
 656:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRDS)
 657:/usr/lib/avr/include/avr/power.h **** #define power_irdriver_enable()         (PRR0 &= (uint8_t)~(1 << PRDS))
 658:/usr/lib/avr/include/avr/power.h **** #define power_irdriver_disable()        (PRR0 |= (uint8_t)(1 << PRDS))
 659:/usr/lib/avr/include/avr/power.h **** #endif
 660:/usr/lib/avr/include/avr/power.h **** 
 661:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRLFR)
 662:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_enable()       (PRR0 &= (uint8_t)~(1 << PRLFR))            
 663:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_disable()      (PRR0 |= (uint8_t)(1 << PRLFR))            
 664:/usr/lib/avr/include/avr/power.h **** #endif
 665:/usr/lib/avr/include/avr/power.h **** 
 666:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRLIN)
 667:/usr/lib/avr/include/avr/power.h **** #define power_lin_enable()              (PRR0 &= (uint8_t)~(1 << PRLIN))
 668:/usr/lib/avr/include/avr/power.h **** #define power_lin_disable()             (PRR0 |= (uint8_t)(1 << PRLIN))
 669:/usr/lib/avr/include/avr/power.h **** #endif
 670:/usr/lib/avr/include/avr/power.h **** 
 671:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRPGA)
 672:/usr/lib/avr/include/avr/power.h **** #define power_pga_enable()              (PRR0 &= (uint8_t)~(1 << PRPGA))
 673:/usr/lib/avr/include/avr/power.h **** #define power_pga_disable()             (PRR0 |= (uint8_t)(1 << PRPGA))
 674:/usr/lib/avr/include/avr/power.h **** #endif
 675:/usr/lib/avr/include/avr/power.h **** 
 676:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRRXDC)
 677:/usr/lib/avr/include/avr/power.h **** #define power_receive_dsp_control_enable()  (PRR0 &= (uint8_t)~(1 << PRRXDC))
 678:/usr/lib/avr/include/avr/power.h **** #define power_receive_dsp_control_disable() (PRR0 |= (uint8_t)(1 << PRRXDC))
 679:/usr/lib/avr/include/avr/power.h **** #endif
 680:/usr/lib/avr/include/avr/power.h **** 
 681:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRSPI)
 682:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()              (PRR0 &= (uint8_t)~(1 << PRSPI))
 683:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()             (PRR0 |= (uint8_t)(1 << PRSPI))
 684:/usr/lib/avr/include/avr/power.h **** #endif
 685:/usr/lib/avr/include/avr/power.h **** 
 686:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT0)
 687:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()           (PRR0 &= (uint8_t)~(1 << PRT0))
 688:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()          (PRR0 |= (uint8_t)(1 << PRT0))
 689:/usr/lib/avr/include/avr/power.h **** #endif
 690:/usr/lib/avr/include/avr/power.h **** 
 691:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM0)
 692:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM0))
 693:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()          (PRR0 |= (uint8_t)(1 << PRTIM0))
 694:/usr/lib/avr/include/avr/power.h **** #endif
 695:/usr/lib/avr/include/avr/power.h **** 
 696:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT1)
 697:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR0 &= (uint8_t)~(1 << PRT1))
 698:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR0 |= (uint8_t)(1 << PRT1))
 699:/usr/lib/avr/include/avr/power.h **** #endif
 700:/usr/lib/avr/include/avr/power.h **** 
 701:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM1)
 702:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM1))
 703:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR0 |= (uint8_t)(1 << PRTIM1))
 704:/usr/lib/avr/include/avr/power.h **** #endif
 705:/usr/lib/avr/include/avr/power.h **** 
 706:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT2)
 707:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR0 &= (uint8_t)~(1 << PRT2))
 708:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR0 |= (uint8_t)(1 << PRT2))
 709:/usr/lib/avr/include/avr/power.h **** #endif
 710:/usr/lib/avr/include/avr/power.h **** 
 711:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM2)
 712:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM2))
 713:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR0 |= (uint8_t)(1 << PRTIM2))
 714:/usr/lib/avr/include/avr/power.h **** #endif
 715:/usr/lib/avr/include/avr/power.h **** 
 716:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT3)
 717:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR0 &= (uint8_t)~(1 << PRT3))
 718:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR0 |= (uint8_t)(1 << PRT3))
 719:/usr/lib/avr/include/avr/power.h **** #endif
 720:/usr/lib/avr/include/avr/power.h **** 
 721:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTM)
 722:/usr/lib/avr/include/avr/power.h **** #define power_timermodulator_enable()   (PRR0 &= (uint8_t)~(1 << PRTM))
 723:/usr/lib/avr/include/avr/power.h **** #define power_timermodulator_disable()  (PRR0 |= (uint8_t)(1 << PRTM))
 724:/usr/lib/avr/include/avr/power.h **** #endif
 725:/usr/lib/avr/include/avr/power.h **** 
 726:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTWI)
 727:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()              (PRR0 &= (uint8_t)~(1 << PRTWI))
 728:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()             (PRR0 |= (uint8_t)(1 << PRTWI))
 729:/usr/lib/avr/include/avr/power.h **** #endif
 730:/usr/lib/avr/include/avr/power.h **** 
 731:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTXDC)
 732:/usr/lib/avr/include/avr/power.h **** #define power_transmit_dsp_control_enable()   (PRR0 &= (uint8_t)~(1 << PRTXDC))
 733:/usr/lib/avr/include/avr/power.h **** #define power_transmit_dsp_control_disable()  (PRR0 |= (uint8_t)(1 << PRTXDC))
 734:/usr/lib/avr/include/avr/power.h **** #endif
 735:/usr/lib/avr/include/avr/power.h **** 
 736:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRUSART0)
 737:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()           (PRR0 &= (uint8_t)~(1 << PRUSART0))
 738:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()          (PRR0 |= (uint8_t)(1 << PRUSART0))
 739:/usr/lib/avr/include/avr/power.h **** #endif
 740:/usr/lib/avr/include/avr/power.h **** 
 741:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRUSART1)
 742:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()           (PRR0 &= (uint8_t)~(1 << PRUSART1))
 743:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()          (PRR0 |= (uint8_t)(1 << PRUSART1))
 744:/usr/lib/avr/include/avr/power.h **** #endif
 745:/usr/lib/avr/include/avr/power.h **** 
 746:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVADC)
 747:/usr/lib/avr/include/avr/power.h **** #define power_vadc_enable()             (PRR0 &= (uint8_t)~(1 << PRVADC))
 748:/usr/lib/avr/include/avr/power.h **** #define power_vadc_disable()            (PRR0 |= (uint8_t)(1 << PRVADC))
 749:/usr/lib/avr/include/avr/power.h **** #endif
 750:/usr/lib/avr/include/avr/power.h **** 
 751:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVM)
 752:/usr/lib/avr/include/avr/power.h **** #define power_voltage_monitor_enable()  (PRR0 &= (uint8_t)~(1 << PRVM))
 753:/usr/lib/avr/include/avr/power.h **** #define power_voltage_monitor_disable() (PRR0 |= (uint8_t)(1 << PRVM))
 754:/usr/lib/avr/include/avr/power.h **** #endif
 755:/usr/lib/avr/include/avr/power.h **** 
 756:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVRM)
 757:/usr/lib/avr/include/avr/power.h **** #define power_vrm_enable()              (PRR0 &= (uint8_t)~(1 << PRVRM))
 758:/usr/lib/avr/include/avr/power.h **** #define power_vrm_disable()             (PRR0 |= (uint8_t)(1 << PRVRM))
 759:/usr/lib/avr/include/avr/power.h **** #endif
 760:/usr/lib/avr/include/avr/power.h **** 
 761:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRAES)
 762:/usr/lib/avr/include/avr/power.h **** #define power_aes_enable()              (PRR1 &= (uint8_t)~(1 << PRAES))
 763:/usr/lib/avr/include/avr/power.h **** #define power_aes_disable()             (PRR1 |= (uint8_t)(1 << PRAES))
 764:/usr/lib/avr/include/avr/power.h **** #endif
 765:/usr/lib/avr/include/avr/power.h **** 
 766:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRCI)
 767:/usr/lib/avr/include/avr/power.h **** #define power_cinterface_enable()       (PRR1 &= (uint8_t)~(1 << PRCI))
 768:/usr/lib/avr/include/avr/power.h **** #define power_cinterface_disable()      (PRR1 |= (uint8_t)(1 << PRCI))
 769:/usr/lib/avr/include/avr/power.h **** #endif
 770:/usr/lib/avr/include/avr/power.h **** 
 771:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRHSSPI)
 772:/usr/lib/avr/include/avr/power.h **** #define power_hsspi_enable()            (PRR1 &= (uint8_t)~(1 << PRHSSPI))
 773:/usr/lib/avr/include/avr/power.h **** #define power_hsspi_disable()           (PRR1 |= (uint8_t)(1 << PRHSSPI))
 774:/usr/lib/avr/include/avr/power.h **** #endif
 775:/usr/lib/avr/include/avr/power.h **** 
 776:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRKB)
 777:/usr/lib/avr/include/avr/power.h **** #define power_kb_enable()               (PRR1 &= (uint8_t)~(1 << PRKB))
 778:/usr/lib/avr/include/avr/power.h **** #define power_kb_disable()              (PRR1 |= (uint8_t)(1 << PRKB))
 779:/usr/lib/avr/include/avr/power.h **** #endif
 780:/usr/lib/avr/include/avr/power.h **** 
 781:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRLFR)
 782:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_enable()       (PRR1 &= (uint8_t)~(1 << PRLFR))            
 783:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_disable()      (PRR1 |= (uint8_t)(1 << PRLFR))            
 784:/usr/lib/avr/include/avr/power.h **** #endif
 785:/usr/lib/avr/include/avr/power.h **** 
 786:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRSCI)
 787:/usr/lib/avr/include/avr/power.h **** #define power_sci_enable()              (PRR1 &= (uint8_t)~(1 << PRSCI))
 788:/usr/lib/avr/include/avr/power.h **** #define power_sci_disable()             (PRR1 |= (uint8_t)(1 << PRSCI))
 789:/usr/lib/avr/include/avr/power.h **** #endif
 790:/usr/lib/avr/include/avr/power.h **** 
 791:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT1)
 792:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR1 &= (uint8_t)~(1 << PRT1))
 793:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR1 |= (uint8_t)(1 << PRT1))
 794:/usr/lib/avr/include/avr/power.h **** #endif
 795:/usr/lib/avr/include/avr/power.h **** 
 796:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT2)
 797:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR1 &= (uint8_t)~(1 << PRT2))
 798:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR1 |= (uint8_t)(1 << PRT2))
 799:/usr/lib/avr/include/avr/power.h **** #endif
 800:/usr/lib/avr/include/avr/power.h **** 
 801:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT3)
 802:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR1 &= (uint8_t)~(1 << PRT3))
 803:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR1 |= (uint8_t)(1 << PRT3))
 804:/usr/lib/avr/include/avr/power.h **** #endif
 805:/usr/lib/avr/include/avr/power.h **** 
 806:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT4)
 807:/usr/lib/avr/include/avr/power.h **** #define power_timer4_enable()           (PRR1 &= (uint8_t)~(1 << PRT4))
 808:/usr/lib/avr/include/avr/power.h **** #define power_timer4_disable()          (PRR1 |= (uint8_t)(1 << PRT4))
 809:/usr/lib/avr/include/avr/power.h **** #endif
 810:/usr/lib/avr/include/avr/power.h **** 
 811:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT5)
 812:/usr/lib/avr/include/avr/power.h **** #define power_timer5_enable()           (PRR1 &= (uint8_t)~(1 << PRT5))
 813:/usr/lib/avr/include/avr/power.h **** #define power_timer5_disable()          (PRR1 |= (uint8_t)(1 << PRT5))
 814:/usr/lib/avr/include/avr/power.h **** #endif
 815:/usr/lib/avr/include/avr/power.h **** 
 816:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM3)
 817:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM3))
 818:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR1 |= (uint8_t)(1 << PRTIM3))
 819:/usr/lib/avr/include/avr/power.h **** #endif
 820:/usr/lib/avr/include/avr/power.h **** 
 821:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM4)
 822:/usr/lib/avr/include/avr/power.h **** #define power_timer4_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM4))
 823:/usr/lib/avr/include/avr/power.h **** #define power_timer4_disable()          (PRR1 |= (uint8_t)(1 << PRTIM4))
 824:/usr/lib/avr/include/avr/power.h **** #endif
 825:/usr/lib/avr/include/avr/power.h **** 
 826:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM5)
 827:/usr/lib/avr/include/avr/power.h **** #define power_timer5_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM5))
 828:/usr/lib/avr/include/avr/power.h **** #define power_timer5_disable()          (PRR1 |= (uint8_t)(1 << PRTIM5))
 829:/usr/lib/avr/include/avr/power.h **** #endif
 830:/usr/lib/avr/include/avr/power.h **** 
 831:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTRX24)
 832:/usr/lib/avr/include/avr/power.h **** #define power_transceiver_enable()      (PRR1 &= (uint8_t)~(1 << PRTRX24))
 833:/usr/lib/avr/include/avr/power.h **** #define power_transceiver_disable()     (PRR1 |= (uint8_t)(1 << PRTRX24))
 834:/usr/lib/avr/include/avr/power.h **** #endif
 835:/usr/lib/avr/include/avr/power.h **** 
 836:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSART1)
 837:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()           (PRR1 &= (uint8_t)~(1 << PRUSART1))
 838:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()          (PRR1 |= (uint8_t)(1 << PRUSART1))
 839:/usr/lib/avr/include/avr/power.h **** #endif
 840:/usr/lib/avr/include/avr/power.h **** 
 841:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSART2)
 842:/usr/lib/avr/include/avr/power.h **** #define power_usart2_enable()           (PRR1 &= (uint8_t)~(1 << PRUSART2))
 843:/usr/lib/avr/include/avr/power.h **** #define power_usart2_disable()          (PRR1 |= (uint8_t)(1 << PRUSART2))
 844:/usr/lib/avr/include/avr/power.h **** #endif
 845:/usr/lib/avr/include/avr/power.h **** 
 846:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSB)
 847:/usr/lib/avr/include/avr/power.h **** #define power_usb_enable()              (PRR1 &= (uint8_t)~(1 << PRUSB))
 848:/usr/lib/avr/include/avr/power.h **** #define power_usb_disable()             (PRR1 |= (uint8_t)(1 << PRUSB))
 849:/usr/lib/avr/include/avr/power.h **** #endif
 850:/usr/lib/avr/include/avr/power.h **** 
 851:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSBH)
 852:/usr/lib/avr/include/avr/power.h **** #define power_usbh_enable()             (PRR1 &= (uint8_t)~(1 << PRUSBH))
 853:/usr/lib/avr/include/avr/power.h **** #define power_usbh_disable()            (PRR1 |= (uint8_t)(1 << PRUSBH))
 854:/usr/lib/avr/include/avr/power.h **** #endif
 855:/usr/lib/avr/include/avr/power.h **** 
 856:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRDF)
 857:/usr/lib/avr/include/avr/power.h **** #define power_data_fifo_enable()        (PRR2 &= (uint8_t)~(1 << PRDF))
 858:/usr/lib/avr/include/avr/power.h **** #define power_data_fifo_disable()       (PRR2 |= (uint8_t)(1 << PRDF))
 859:/usr/lib/avr/include/avr/power.h **** #endif
 860:/usr/lib/avr/include/avr/power.h **** 
 861:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRIDS)
 862:/usr/lib/avr/include/avr/power.h **** #define power_id_scan_enable()          (PRR2 &= (uint8_t)~(1 << PRIDS))
 863:/usr/lib/avr/include/avr/power.h **** #define power_id_scan_disable()         (PRR2 |= (uint8_t)(1 << PRIDS))
 864:/usr/lib/avr/include/avr/power.h **** #endif
 865:/usr/lib/avr/include/avr/power.h **** 
 866:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM0)
 867:/usr/lib/avr/include/avr/power.h **** #define power_ram0_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM0))
 868:/usr/lib/avr/include/avr/power.h **** #define power_ram0_disable()            (PRR2 |= (uint8_t)(1 << PRRAM0))
 869:/usr/lib/avr/include/avr/power.h **** #endif
 870:/usr/lib/avr/include/avr/power.h **** 
 871:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM1)
 872:/usr/lib/avr/include/avr/power.h **** #define power_ram1_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM1))
 873:/usr/lib/avr/include/avr/power.h **** #define power_ram1_disable()            (PRR2 |= (uint8_t)(1 << PRRAM1))
 874:/usr/lib/avr/include/avr/power.h **** #endif
 875:/usr/lib/avr/include/avr/power.h **** 
 876:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM2)
 877:/usr/lib/avr/include/avr/power.h **** #define power_ram2_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM2))
 878:/usr/lib/avr/include/avr/power.h **** #define power_ram2_disable()            (PRR2 |= (uint8_t)(1 << PRRAM2))
 879:/usr/lib/avr/include/avr/power.h **** #endif
 880:/usr/lib/avr/include/avr/power.h **** 
 881:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM3)
 882:/usr/lib/avr/include/avr/power.h **** #define power_ram3_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM3))
 883:/usr/lib/avr/include/avr/power.h **** #define power_ram3_disable()            (PRR2 |= (uint8_t)(1 << PRRAM3))
 884:/usr/lib/avr/include/avr/power.h **** #endif
 885:/usr/lib/avr/include/avr/power.h **** 
 886:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRS)
 887:/usr/lib/avr/include/avr/power.h **** #define power_rssi_buffer_enable()      (PRR2 &= (uint8_t)~(1 << PRRS))
 888:/usr/lib/avr/include/avr/power.h **** #define power_rssi_buffer_disable()     (PRR2 |= (uint8_t)(1 << PRRS))
 889:/usr/lib/avr/include/avr/power.h **** #endif
 890:/usr/lib/avr/include/avr/power.h **** 
 891:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRSF)
 892:/usr/lib/avr/include/avr/power.h **** #define power_preamble_rssi_fifo_enable()       (PRR2 &= (uint8_t)~(1 << PRSF))
 893:/usr/lib/avr/include/avr/power.h **** #define power_preamble_rssi_fifo_disable()      (PRR2 |= (uint8_t)(1 << PRSF))
 894:/usr/lib/avr/include/avr/power.h **** #endif
 895:/usr/lib/avr/include/avr/power.h **** 
 896:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRSSM)
 897:/usr/lib/avr/include/avr/power.h **** #define power_sequencer_state_machine_enable()  (PRR2 &= (uint8_t)~(1 << PRSSM))
 898:/usr/lib/avr/include/avr/power.h **** #define power_sequencer_state_machine_disable() (PRR2 |= (uint8_t)(1 << PRSSM))
 899:/usr/lib/avr/include/avr/power.h **** #endif
 900:/usr/lib/avr/include/avr/power.h **** 
 901:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRTM)
 902:/usr/lib/avr/include/avr/power.h **** #define power_tx_modulator_enable()     (PRR2 &= (uint8_t)~(1 << PRTM))
 903:/usr/lib/avr/include/avr/power.h **** #define power_tx_modulator_disable()    (PRR2 |= (uint8_t)(1 << PRTM))
 904:/usr/lib/avr/include/avr/power.h **** #endif
 905:/usr/lib/avr/include/avr/power.h **** 
 906:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRXA)
 907:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_A_enable()      (PRR2 &= (uint8_t)~(1 << PRXA))
 908:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_A_disable()     (PRR2 |= (uint8_t)(1 << PRXA))
 909:/usr/lib/avr/include/avr/power.h **** #endif
 910:/usr/lib/avr/include/avr/power.h **** 
 911:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRXB)
 912:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_B_enable()      (PRR2 &= (uint8_t)~(1 << PRXB))
 913:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_B_disable()     (PRR2 |= (uint8_t)(1 << PRXB))
 914:/usr/lib/avr/include/avr/power.h **** #endif
 915:/usr/lib/avr/include/avr/power.h **** 
 916:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_AES)
 917:/usr/lib/avr/include/avr/power.h **** #define power_aes_enable()              (PR_PRGEN &= (uint8_t)~(PR_AES_bm))
 918:/usr/lib/avr/include/avr/power.h **** #define power_aes_disable()             (PR_PRGEN |= (uint8_t)PR_AES_bm)
 919:/usr/lib/avr/include/avr/power.h **** #endif
 920:/usr/lib/avr/include/avr/power.h **** 
 921:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_DMA)
 922:/usr/lib/avr/include/avr/power.h **** #define power_dma_enable()              (PR_PRGEN &= (uint8_t)~(PR_DMA_bm))
 923:/usr/lib/avr/include/avr/power.h **** #define power_dma_disable()             (PR_PRGEN |= (uint8_t)PR_DMA_bm)
 924:/usr/lib/avr/include/avr/power.h **** #endif
 925:/usr/lib/avr/include/avr/power.h **** 
 926:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EBI)
 927:/usr/lib/avr/include/avr/power.h **** #define power_ebi_enable()              (PR_PRGEN &= (uint8_t)~(PR_EBI_bm))
 928:/usr/lib/avr/include/avr/power.h **** #define power_ebi_disable()             (PR_PRGEN |= (uint8_t)PR_EBI_bm)
 929:/usr/lib/avr/include/avr/power.h **** #endif
 930:/usr/lib/avr/include/avr/power.h **** 
 931:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EDMA)
 932:/usr/lib/avr/include/avr/power.h **** #define power_edma_enable()             (PR_PRGEN &= (uint8_t)~(PR_EDMA_bm))
 933:/usr/lib/avr/include/avr/power.h **** #define power_edma_disable()            (PR_PRGEN |= (uint8_t)PR_EDMA_bm)
 934:/usr/lib/avr/include/avr/power.h **** #endif
 935:/usr/lib/avr/include/avr/power.h **** 
 936:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EVSYS)
 937:/usr/lib/avr/include/avr/power.h **** #define power_evsys_enable()            (PR_PRGEN &= (uint8_t)~(PR_EVSYS_bm))
 938:/usr/lib/avr/include/avr/power.h **** #define power_evsys_disable()           (PR_PRGEN |= (uint8_t)PR_EVSYS_bm)
 939:/usr/lib/avr/include/avr/power.h **** #endif
 940:/usr/lib/avr/include/avr/power.h **** 
 941:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_LCD)
 942:/usr/lib/avr/include/avr/power.h **** #define power_lcd_enable()              (PR_PRGEN &= (uint8_t)~(PR_LCD_bm))
 943:/usr/lib/avr/include/avr/power.h **** #define power_lcd_disable()             (PR_PRGEN |= (uint8_t)PR_LCD_bm)
 944:/usr/lib/avr/include/avr/power.h **** #endif
 945:/usr/lib/avr/include/avr/power.h **** 
 946:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_RTC)
 947:/usr/lib/avr/include/avr/power.h **** #define power_rtc_enable()              (PR_PRGEN &= (uint8_t)~(PR_RTC_bm))
 948:/usr/lib/avr/include/avr/power.h **** #define power_rtc_disable()             (PR_PRGEN |= (uint8_t)PR_RTC_bm)
 949:/usr/lib/avr/include/avr/power.h **** #endif
 950:/usr/lib/avr/include/avr/power.h **** 
 951:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_USB)
 952:/usr/lib/avr/include/avr/power.h **** #define power_usb_enable()              (PR_PRGEN &= (uint8_t)~(PR_USB_bm))
 953:/usr/lib/avr/include/avr/power.h **** #define power_usb_disable()             (PR_PRGEN &= (uint8_t)(PR_USB_bm))
 954:/usr/lib/avr/include/avr/power.h **** #endif
 955:/usr/lib/avr/include/avr/power.h **** 
 956:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_XCL)
 957:/usr/lib/avr/include/avr/power.h **** #define power_xcl_enable()              (PR_PRGEN &= (uint8_t)~(PR_XCL_bm))
 958:/usr/lib/avr/include/avr/power.h **** #define power_xcl_disable()             (PR_PRGEN |= (uint8_t)PR_XCL_bm)
 959:/usr/lib/avr/include/avr/power.h **** #endif
 960:/usr/lib/avr/include/avr/power.h **** 
 961:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_AC)
 962:/usr/lib/avr/include/avr/power.h **** #define power_aca_enable()      (PR_PRPA &= (uint8_t)~(PR_AC_bm))
 963:/usr/lib/avr/include/avr/power.h **** #define power_aca_disable()     (PR_PRPA |= (uint8_t)PR_AC_bm)
 964:/usr/lib/avr/include/avr/power.h **** #endif
 965:/usr/lib/avr/include/avr/power.h **** 
 966:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_ADC)
 967:/usr/lib/avr/include/avr/power.h **** #define power_adca_enable()     (PR_PRPA &= (uint8_t)~(PR_ADC_bm))
 968:/usr/lib/avr/include/avr/power.h **** #define power_adca_disable()    (PR_PRPA |= (uint8_t)PR_ADC_bm)
 969:/usr/lib/avr/include/avr/power.h **** #endif
 970:/usr/lib/avr/include/avr/power.h **** 
 971:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_DAC)
 972:/usr/lib/avr/include/avr/power.h **** #define power_daca_enable()     (PR_PRPA &= (uint8_t)~(PR_DAC_bm))
 973:/usr/lib/avr/include/avr/power.h **** #define power_daca_disable()    (PR_PRPA |= (uint8_t)PR_DAC_bm)
 974:/usr/lib/avr/include/avr/power.h **** #endif
 975:/usr/lib/avr/include/avr/power.h **** 
 976:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_AC)
 977:/usr/lib/avr/include/avr/power.h **** #define power_acb_enable()      (PR_PRPB &= (uint8_t)~(PR_AC_bm))
 978:/usr/lib/avr/include/avr/power.h **** #define power_acb_disable()     (PR_PRPB |= (uint8_t)PR_AC_bm)
 979:/usr/lib/avr/include/avr/power.h **** #endif
 980:/usr/lib/avr/include/avr/power.h **** 
 981:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_ADC)
 982:/usr/lib/avr/include/avr/power.h **** #define power_adcb_enable()     (PR_PRPB &= (uint8_t)~(PR_ADC_bm))
 983:/usr/lib/avr/include/avr/power.h **** #define power_adcb_disable()    (PR_PRPB |= (uint8_t)PR_ADC_bm)
 984:/usr/lib/avr/include/avr/power.h **** #endif
 985:/usr/lib/avr/include/avr/power.h **** 
 986:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_DAC)
 987:/usr/lib/avr/include/avr/power.h **** #define power_dacb_enable()     (PR_PRPB &= (uint8_t)~(PR_DAC_bm))
 988:/usr/lib/avr/include/avr/power.h **** #define power_dacb_disable()    (PR_PRPB |= (uint8_t)PR_DAC_bm)
 989:/usr/lib/avr/include/avr/power.h **** #endif
 990:/usr/lib/avr/include/avr/power.h **** 
 991:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_HIRES)
 992:/usr/lib/avr/include/avr/power.h **** #define power_hiresc_enable()   (PR_PRPC &= (uint8_t)~(PR_HIRES_bm))
 993:/usr/lib/avr/include/avr/power.h **** #define power_hiresc_disable()  (PR_PRPC |= (uint8_t)PR_HIRES_bm)
 994:/usr/lib/avr/include/avr/power.h **** #endif
 995:/usr/lib/avr/include/avr/power.h **** 
 996:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_SPI)
 997:/usr/lib/avr/include/avr/power.h **** #define power_spic_enable()     (PR_PRPC &= (uint8_t)~(PR_SPI_bm))
 998:/usr/lib/avr/include/avr/power.h **** #define power_spic_disable()    (PR_PRPC |= (uint8_t)PR_SPI_bm)
 999:/usr/lib/avr/include/avr/power.h **** #endif
1000:/usr/lib/avr/include/avr/power.h **** 
1001:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC0)
1002:/usr/lib/avr/include/avr/power.h **** #define power_tc0c_enable()     (PR_PRPC &= (uint8_t)~(PR_TC0_bm))
1003:/usr/lib/avr/include/avr/power.h **** #define power_tc0c_disable()    (PR_PRPC |= (uint8_t)PR_TC0_bm)
1004:/usr/lib/avr/include/avr/power.h **** #endif
1005:/usr/lib/avr/include/avr/power.h **** 
1006:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC1)
1007:/usr/lib/avr/include/avr/power.h **** #define power_tc1c_enable()     (PR_PRPC &= (uint8_t)~(PR_TC1_bm))
1008:/usr/lib/avr/include/avr/power.h **** #define power_tc1c_disable()    (PR_PRPC |= (uint8_t)PR_TC1_bm)
1009:/usr/lib/avr/include/avr/power.h **** #endif
1010:/usr/lib/avr/include/avr/power.h **** 
1011:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC4)
1012:/usr/lib/avr/include/avr/power.h **** #define power_tc4c_enable()     (PR_PRPC  &= (uint8_t)~(PR_TC4_bm))
1013:/usr/lib/avr/include/avr/power.h **** #define power_tc4c_disable()    (PR_PRPC  |= (uint8_t)PR_TC4_bm)
1014:/usr/lib/avr/include/avr/power.h **** #endif
1015:/usr/lib/avr/include/avr/power.h **** 
1016:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC5)
1017:/usr/lib/avr/include/avr/power.h **** #define power_tc5c_enable()     (PR_PRPC  &= (uint8_t)~(PR_TC5_bm))
1018:/usr/lib/avr/include/avr/power.h **** #define power_tc5c_disable()    (PR_PRPC  |= (uint8_t)PR_TC5_bm)
1019:/usr/lib/avr/include/avr/power.h **** #endif
1020:/usr/lib/avr/include/avr/power.h **** 
1021:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TWI)
1022:/usr/lib/avr/include/avr/power.h **** #define power_twic_enable()     (PR_PRPC &= (uint8_t)~(PR_TWI_bm))
1023:/usr/lib/avr/include/avr/power.h **** #define power_twic_disable()    (PR_PRPC |= (uint8_t)PR_TWI_bm)
1024:/usr/lib/avr/include/avr/power.h **** #endif
1025:/usr/lib/avr/include/avr/power.h **** 
1026:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_USART0)
1027:/usr/lib/avr/include/avr/power.h **** #define power_usartc0_enable()  (PR_PRPC &= (uint8_t)~(PR_USART0_bm))
1028:/usr/lib/avr/include/avr/power.h **** #define power_usartc0_disable() (PR_PRPC |= (uint8_t)PR_USART0_bm)
1029:/usr/lib/avr/include/avr/power.h **** #endif
1030:/usr/lib/avr/include/avr/power.h **** 
1031:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_USART1)
1032:/usr/lib/avr/include/avr/power.h **** #define power_usartc1_enable()  (PR_PRPC &= (uint8_t)~(PR_USART1_bm))
1033:/usr/lib/avr/include/avr/power.h **** #define power_usartc1_disable() (PR_PRPC |= (uint8_t)PR_USART1_bm)
1034:/usr/lib/avr/include/avr/power.h **** #endif
1035:/usr/lib/avr/include/avr/power.h **** 
1036:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_HIRES)
1037:/usr/lib/avr/include/avr/power.h **** #define power_hiresd_enable()   (PR_PRPD &= (uint8_t)~(PR_HIRES_bm))
1038:/usr/lib/avr/include/avr/power.h **** #define power_hiresd_disable()  (PR_PRPD |= (uint8_t)PR_HIRES_bm)
1039:/usr/lib/avr/include/avr/power.h **** #endif
1040:/usr/lib/avr/include/avr/power.h **** 
1041:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_SPI)
1042:/usr/lib/avr/include/avr/power.h **** #define power_spid_enable()     (PR_PRPD &= (uint8_t)~(PR_SPI_bm))
1043:/usr/lib/avr/include/avr/power.h **** #define power_spid_disable()    (PR_PRPD |= (uint8_t)PR_SPI_bm)
1044:/usr/lib/avr/include/avr/power.h **** #endif
1045:/usr/lib/avr/include/avr/power.h **** 
1046:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC0)
1047:/usr/lib/avr/include/avr/power.h **** #define power_tc0d_enable()     (PR_PRPD &= (uint8_t)~(PR_TC0_bm))
1048:/usr/lib/avr/include/avr/power.h **** #define power_tc0d_disable()    (PR_PRPD |= (uint8_t)PR_TC0_bm)
1049:/usr/lib/avr/include/avr/power.h **** #endif
1050:/usr/lib/avr/include/avr/power.h **** 
1051:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC1)
1052:/usr/lib/avr/include/avr/power.h **** #define power_tc1d_enable()     (PR_PRPD &= (uint8_t)~(PR_TC1_bm))
1053:/usr/lib/avr/include/avr/power.h **** #define power_tc1d_disable()    (PR_PRPD |= (uint8_t)PR_TC1_bm)
1054:/usr/lib/avr/include/avr/power.h **** #endif
1055:/usr/lib/avr/include/avr/power.h **** 
1056:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC5)
1057:/usr/lib/avr/include/avr/power.h **** #define power_tc5d_enable()     (PR_PRPD  &= (uint8_t)~(PR_TC5_bm))
1058:/usr/lib/avr/include/avr/power.h **** #define power_tc5d_disable()    (PR_PRPD  |= (uint8_t)PR_TC5_bm)
1059:/usr/lib/avr/include/avr/power.h **** #endif
1060:/usr/lib/avr/include/avr/power.h **** 
1061:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TWI)
1062:/usr/lib/avr/include/avr/power.h **** #define power_twid_enable()     (PR_PRPD &= (uint8_t)~(PR_TWI_bm))
1063:/usr/lib/avr/include/avr/power.h **** #define power_twid_disable()    (PR_PRPD |= (uint8_t)PR_TWI_bm)
1064:/usr/lib/avr/include/avr/power.h **** #endif
1065:/usr/lib/avr/include/avr/power.h **** 
1066:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_USART0)
1067:/usr/lib/avr/include/avr/power.h **** #define power_usartd0_enable()  (PR_PRPD &= (uint8_t)~(PR_USART0_bm))
1068:/usr/lib/avr/include/avr/power.h **** #define power_usartd0_disable() (PR_PRPD |= (uint8_t)PR_USART0_bm)
1069:/usr/lib/avr/include/avr/power.h **** #endif
1070:/usr/lib/avr/include/avr/power.h **** 
1071:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_USART1)
1072:/usr/lib/avr/include/avr/power.h **** #define power_usartd1_enable()  (PR_PRPD &= (uint8_t)~(PR_USART1_bm))
1073:/usr/lib/avr/include/avr/power.h **** #define power_usartd1_disable() (PR_PRPD |= (uint8_t)PR_USART1_bm)
1074:/usr/lib/avr/include/avr/power.h **** #endif
1075:/usr/lib/avr/include/avr/power.h **** 
1076:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_HIRES)
1077:/usr/lib/avr/include/avr/power.h **** #define power_hirese_enable()   (PR_PRPE &= (uint8_t)~(PR_HIRES_bm))
1078:/usr/lib/avr/include/avr/power.h **** #define power_hirese_disable()  (PR_PRPE |= (uint8_t)PR_HIRES_bm)
1079:/usr/lib/avr/include/avr/power.h **** #endif
1080:/usr/lib/avr/include/avr/power.h **** 
1081:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_SPI)
1082:/usr/lib/avr/include/avr/power.h **** #define power_spie_enable()     (PR_PRPE &= (uint8_t)~(PR_SPI_bm))
1083:/usr/lib/avr/include/avr/power.h **** #define power_spie_disable()    (PR_PRPE |= (uint8_t)PR_SPI_bm)
1084:/usr/lib/avr/include/avr/power.h **** #endif
1085:/usr/lib/avr/include/avr/power.h **** 
1086:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TC0)
1087:/usr/lib/avr/include/avr/power.h **** #define power_tc0e_enable()     (PR_PRPE &= (uint8_t)~(PR_TC0_bm))
1088:/usr/lib/avr/include/avr/power.h **** #define power_tc0e_disable()    (PR_PRPE |= (uint8_t)PR_TC0_bm)
1089:/usr/lib/avr/include/avr/power.h **** #endif
1090:/usr/lib/avr/include/avr/power.h **** 
1091:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TC1)
1092:/usr/lib/avr/include/avr/power.h **** #define power_tc1e_enable()     (PR_PRPE &= (uint8_t)~(PR_TC1_bm))
1093:/usr/lib/avr/include/avr/power.h **** #define power_tc1e_disable()    (PR_PRPE |= (uint8_t)PR_TC1_bm)
1094:/usr/lib/avr/include/avr/power.h **** #endif
1095:/usr/lib/avr/include/avr/power.h **** 
1096:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TWI)
1097:/usr/lib/avr/include/avr/power.h **** #define power_twie_enable()     (PR_PRPE &= (uint8_t)~(PR_TWI_bm))
1098:/usr/lib/avr/include/avr/power.h **** #define power_twie_disable()    (PR_PRPE |= (uint8_t)PR_TWI_bm)
1099:/usr/lib/avr/include/avr/power.h **** #endif
1100:/usr/lib/avr/include/avr/power.h **** 
1101:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_USART0)
1102:/usr/lib/avr/include/avr/power.h **** #define power_usarte0_enable()  (PR_PRPE &= (uint8_t)~(PR_USART0_bm))
1103:/usr/lib/avr/include/avr/power.h **** #define power_usarte0_disable() (PR_PRPE |= (uint8_t)PR_USART0_bm)
1104:/usr/lib/avr/include/avr/power.h **** #endif
1105:/usr/lib/avr/include/avr/power.h **** 
1106:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_USART1)
1107:/usr/lib/avr/include/avr/power.h **** #define power_usarte1_enable()  (PR_PRPE &= (uint8_t)~(PR_USART1_bm))
1108:/usr/lib/avr/include/avr/power.h **** #define power_usarte1_disable() (PR_PRPE |= (uint8_t)PR_USART1_bm)
1109:/usr/lib/avr/include/avr/power.h **** #endif
1110:/usr/lib/avr/include/avr/power.h **** 
1111:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_HIRES)
1112:/usr/lib/avr/include/avr/power.h **** #define power_hiresf_enable()   (PR_PRPF &= (uint8_t)~(PR_HIRES_bm))
1113:/usr/lib/avr/include/avr/power.h **** #define power_hiresf_disable()  (PR_PRPF |= (uint8_t)PR_HIRES_bm)
1114:/usr/lib/avr/include/avr/power.h **** #endif
1115:/usr/lib/avr/include/avr/power.h **** 
1116:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_SPI)
1117:/usr/lib/avr/include/avr/power.h **** #define power_spif_enable()     (PR_PRPF &= (uint8_t)~(PR_SPI_bm))
1118:/usr/lib/avr/include/avr/power.h **** #define power_spif_disable()    (PR_PRPF |= (uint8_t)PR_SPI_bm)
1119:/usr/lib/avr/include/avr/power.h **** #endif
1120:/usr/lib/avr/include/avr/power.h **** 
1121:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TC0)
1122:/usr/lib/avr/include/avr/power.h **** #define power_tc0f_enable()     (PR_PRPF &= (uint8_t)~(PR_TC0_bm))
1123:/usr/lib/avr/include/avr/power.h **** #define power_tc0f_disable()    (PR_PRPF |= (uint8_t)PR_TC0_bm)
1124:/usr/lib/avr/include/avr/power.h **** #endif
1125:/usr/lib/avr/include/avr/power.h **** 
1126:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TC1)
1127:/usr/lib/avr/include/avr/power.h **** #define power_tc1f_enable()     (PR_PRPF &= (uint8_t)~(PR_TC1_bm))
1128:/usr/lib/avr/include/avr/power.h **** #define power_tc1f_disable()    (PR_PRPF |= (uint8_t)PR_TC1_bm)
1129:/usr/lib/avr/include/avr/power.h **** #endif
1130:/usr/lib/avr/include/avr/power.h **** 
1131:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TWI)
1132:/usr/lib/avr/include/avr/power.h **** #define power_twif_enable()     (PR_PRPF &= (uint8_t)~(PR_TWI_bm))
1133:/usr/lib/avr/include/avr/power.h **** #define power_twif_disable()    (PR_PRPF |= (uint8_t)PR_TWI_bm)
1134:/usr/lib/avr/include/avr/power.h **** #endif
1135:/usr/lib/avr/include/avr/power.h **** 
1136:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_USART0)
1137:/usr/lib/avr/include/avr/power.h **** #define power_usartf0_enable()  (PR_PRPF &= (uint8_t)~(PR_USART0_bm))
1138:/usr/lib/avr/include/avr/power.h **** #define power_usartf0_disable() (PR_PRPF |= (uint8_t)PR_USART0_bm)
1139:/usr/lib/avr/include/avr/power.h **** #endif
1140:/usr/lib/avr/include/avr/power.h **** 
1141:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_USART1)
1142:/usr/lib/avr/include/avr/power.h **** #define power_usartf1_enable()  (PR_PRPF &= (uint8_t)~(PR_USART1_bm))
1143:/usr/lib/avr/include/avr/power.h **** #define power_usartf1_disable() (PR_PRPF |= (uint8_t)PR_USART1_bm)
1144:/usr/lib/avr/include/avr/power.h **** #endif
1145:/usr/lib/avr/include/avr/power.h **** 
1146:/usr/lib/avr/include/avr/power.h **** 
1147:/usr/lib/avr/include/avr/power.h **** static __inline void
1148:/usr/lib/avr/include/avr/power.h **** __attribute__ ((__always_inline__))
1149:/usr/lib/avr/include/avr/power.h **** __power_all_enable()
1150:/usr/lib/avr/include/avr/power.h **** {
1151:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR
1152:/usr/lib/avr/include/avr/power.h ****     PRR &= (uint8_t)~(__AVR_HAVE_PRR);
1153:/usr/lib/avr/include/avr/power.h **** #endif
1154:/usr/lib/avr/include/avr/power.h **** 
1155:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR0
1156:/usr/lib/avr/include/avr/power.h ****     PRR0 &= (uint8_t)~(__AVR_HAVE_PRR0);
1157:/usr/lib/avr/include/avr/power.h **** #endif
1158:/usr/lib/avr/include/avr/power.h **** 
1159:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR1
1160:/usr/lib/avr/include/avr/power.h ****     PRR1 &= (uint8_t)~(__AVR_HAVE_PRR1);
1161:/usr/lib/avr/include/avr/power.h **** #endif
1162:/usr/lib/avr/include/avr/power.h **** 
1163:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR2
1164:/usr/lib/avr/include/avr/power.h ****    PRR2 &= (uint8_t)~(__AVR_HAVE_PRR2);
1165:/usr/lib/avr/include/avr/power.h **** #endif
1166:/usr/lib/avr/include/avr/power.h **** 
1167:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRGEN
1168:/usr/lib/avr/include/avr/power.h ****     PR_PRGEN &= (uint8_t)~(__AVR_HAVE_PRGEN);
1169:/usr/lib/avr/include/avr/power.h **** #endif
1170:/usr/lib/avr/include/avr/power.h **** 
1171:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPA
1172:/usr/lib/avr/include/avr/power.h ****     PR_PRPA &= (uint8_t)~(__AVR_HAVE_PRPA);
1173:/usr/lib/avr/include/avr/power.h **** #endif
1174:/usr/lib/avr/include/avr/power.h **** 
1175:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPB
1176:/usr/lib/avr/include/avr/power.h ****     PR_PRPB &= (uint8_t)~(__AVR_HAVE_PRPB);
1177:/usr/lib/avr/include/avr/power.h **** #endif
1178:/usr/lib/avr/include/avr/power.h **** 
1179:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPC
1180:/usr/lib/avr/include/avr/power.h ****     PR_PRPC &= (uint8_t)~(__AVR_HAVE_PRPC);
1181:/usr/lib/avr/include/avr/power.h **** #endif
1182:/usr/lib/avr/include/avr/power.h **** 
1183:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPD
1184:/usr/lib/avr/include/avr/power.h ****     PR_PRPD &= (uint8_t)~(__AVR_HAVE_PRPD);
1185:/usr/lib/avr/include/avr/power.h **** #endif
1186:/usr/lib/avr/include/avr/power.h **** 
1187:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPE
1188:/usr/lib/avr/include/avr/power.h ****     PR_PRPE &= (uint8_t)~(__AVR_HAVE_PRPE);
1189:/usr/lib/avr/include/avr/power.h **** #endif
1190:/usr/lib/avr/include/avr/power.h **** 
1191:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPF
1192:/usr/lib/avr/include/avr/power.h ****     PR_PRPF &= (uint8_t)~(__AVR_HAVE_PRPF);
1193:/usr/lib/avr/include/avr/power.h **** #endif
1194:/usr/lib/avr/include/avr/power.h **** }
1195:/usr/lib/avr/include/avr/power.h **** 
1196:/usr/lib/avr/include/avr/power.h **** static __inline void
1197:/usr/lib/avr/include/avr/power.h **** __attribute__ ((__always_inline__))
1198:/usr/lib/avr/include/avr/power.h **** __power_all_disable()
1199:/usr/lib/avr/include/avr/power.h **** {
1200:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR
1201:/usr/lib/avr/include/avr/power.h ****     PRR |= (uint8_t)(__AVR_HAVE_PRR);
1202:/usr/lib/avr/include/avr/power.h **** #endif
1203:/usr/lib/avr/include/avr/power.h **** 
1204:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR0
1205:/usr/lib/avr/include/avr/power.h ****     PRR0 |= (uint8_t)(__AVR_HAVE_PRR0);
1206:/usr/lib/avr/include/avr/power.h **** #endif
1207:/usr/lib/avr/include/avr/power.h **** 
1208:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR1
1209:/usr/lib/avr/include/avr/power.h ****     PRR1 |= (uint8_t)(__AVR_HAVE_PRR1);
1210:/usr/lib/avr/include/avr/power.h **** #endif
1211:/usr/lib/avr/include/avr/power.h **** 
1212:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR2
1213:/usr/lib/avr/include/avr/power.h ****     PRR2 |= (uint8_t)(__AVR_HAVE_PRR2);
1214:/usr/lib/avr/include/avr/power.h **** #endif
1215:/usr/lib/avr/include/avr/power.h **** 
1216:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRGEN
1217:/usr/lib/avr/include/avr/power.h ****     PR_PRGEN |= (uint8_t)(__AVR_HAVE_PRGEN);
1218:/usr/lib/avr/include/avr/power.h **** #endif
1219:/usr/lib/avr/include/avr/power.h **** 
1220:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPA
1221:/usr/lib/avr/include/avr/power.h ****     PR_PRPA |= (uint8_t)(__AVR_HAVE_PRPA);
1222:/usr/lib/avr/include/avr/power.h **** #endif
1223:/usr/lib/avr/include/avr/power.h **** 
1224:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPB
1225:/usr/lib/avr/include/avr/power.h ****     PR_PRPB |= (uint8_t)(__AVR_HAVE_PRPB);
1226:/usr/lib/avr/include/avr/power.h **** #endif
1227:/usr/lib/avr/include/avr/power.h **** 
1228:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPC
1229:/usr/lib/avr/include/avr/power.h ****     PR_PRPC |= (uint8_t)(__AVR_HAVE_PRPC);
1230:/usr/lib/avr/include/avr/power.h **** #endif
1231:/usr/lib/avr/include/avr/power.h **** 
1232:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPD
1233:/usr/lib/avr/include/avr/power.h ****     PR_PRPD |= (uint8_t)(__AVR_HAVE_PRPD);
1234:/usr/lib/avr/include/avr/power.h **** #endif
1235:/usr/lib/avr/include/avr/power.h **** 
1236:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPE
1237:/usr/lib/avr/include/avr/power.h ****     PR_PRPE |= (uint8_t)(__AVR_HAVE_PRPE);
1238:/usr/lib/avr/include/avr/power.h **** #endif
1239:/usr/lib/avr/include/avr/power.h **** 
1240:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPF
1241:/usr/lib/avr/include/avr/power.h ****     PR_PRPF |= (uint8_t)(__AVR_HAVE_PRPF);
1242:/usr/lib/avr/include/avr/power.h **** #endif
1243:/usr/lib/avr/include/avr/power.h **** }
1244:/usr/lib/avr/include/avr/power.h **** 
1245:/usr/lib/avr/include/avr/power.h **** #ifndef power_all_enable
1246:/usr/lib/avr/include/avr/power.h **** #define power_all_enable() __power_all_enable()
1247:/usr/lib/avr/include/avr/power.h **** #endif
1248:/usr/lib/avr/include/avr/power.h **** 
1249:/usr/lib/avr/include/avr/power.h **** #ifndef power_all_disable
1250:/usr/lib/avr/include/avr/power.h **** #define power_all_disable() __power_all_disable()
1251:/usr/lib/avr/include/avr/power.h **** #endif
1252:/usr/lib/avr/include/avr/power.h **** 
1253:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_AT90CAN32__) \
1254:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90CAN64__) \
1255:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90CAN128__) \
1256:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM1__) \
1257:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM2__) \
1258:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM2B__) \
1259:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM3__) \
1260:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM3B__) \
1261:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM81__) \
1262:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM161__) \
1263:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM216__) \
1264:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM316__) \
1265:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90SCR100__) \
1266:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB646__) \
1267:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB647__) \
1268:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB82__) \
1269:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB1286__) \
1270:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB1287__) \
1271:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB162__) \
1272:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA5505__) \
1273:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA5272__) \
1274:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA6617C__) \
1275:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA664251__) \
1276:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1280__) \
1277:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1281__) \
1278:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284__) \
1279:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFA1__) \
1280:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFR2__) \
1281:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284RFR2__) \
1282:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284P__) \
1283:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega162__) \
1284:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164A__) \
1285:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164P__) \
1286:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164PA__) \
1287:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165__) \
1288:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165A__) \
1289:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165P__) \
1290:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165PA__) \
1291:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168__) \
1292:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168A__) \
1293:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168P__) \
1294:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168PA__) \
1295:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168PB__) \
1296:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169__) \
1297:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169A__) \
1298:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169P__) \
1299:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169PA__) \
1300:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16M1__) \
1301:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U2__) \
1302:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324PA__) \
1303:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U4__) \
1304:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2560__) \
1305:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2561__) \
1306:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega256RFR2__) \
1307:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2564RFR2__) \
1308:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324A__) \
1309:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324P__) \
1310:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325__) \
1311:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325A__) \
1312:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325P__) \
1313:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325PA__) \
1314:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250__) \
1315:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250A__) \
1316:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250P__) \
1317:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250PA__) \
1318:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega328__) \
1319:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega328P__) \
1320:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329__) \
1321:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329A__) \
1322:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329P__) \
1323:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329PA__) \
1324:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290__) \
1325:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290A__) \
1326:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290P__) \
1327:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290PA__) \
1328:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32C1__) \
1329:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32M1__) \
1330:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U2__) \
1331:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U4__) \
1332:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U6__) \
1333:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48__) \
1334:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48A__) \
1335:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48PA__) \
1336:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48PB__) \
1337:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48P__) \
1338:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega640__) \
1339:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649P__) \
1340:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644__) \
1341:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644A__) \
1342:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644P__) \
1343:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644PA__) \
1344:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645__) \
1345:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645A__) \
1346:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645P__) \
1347:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450__) \
1348:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450A__) \
1349:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450P__) \
1350:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649__) \
1351:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649A__) \
1352:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64M1__) \
1353:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64C1__) \
1354:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88A__) \
1355:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88PA__) \
1356:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88PB__) \
1357:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490__) \
1358:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490A__) \
1359:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490P__) \
1360:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64RFR2__) \
1361:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644RFR2__) \
1362:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88__) \
1363:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88P__) \
1364:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega8U2__) \
1365:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U2__) \
1366:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U2__) \
1367:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny48__) \
1368:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny88__) \
1369:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny87__) \
1370:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny167__) \
1371:/usr/lib/avr/include/avr/power.h **** || defined(__DOXYGEN__)
1372:/usr/lib/avr/include/avr/power.h **** 
1373:/usr/lib/avr/include/avr/power.h **** 
1374:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
1375:/usr/lib/avr/include/avr/power.h **** 
1376:/usr/lib/avr/include/avr/power.h **** Some of the newer AVRs contain a System Clock Prescale Register (CLKPR) that
1377:/usr/lib/avr/include/avr/power.h **** allows you to decrease the system clock frequency and the power consumption
1378:/usr/lib/avr/include/avr/power.h **** when the need for processing power is low.
1379:/usr/lib/avr/include/avr/power.h **** On some earlier AVRs (ATmega103, ATmega64, ATmega128), similar
1380:/usr/lib/avr/include/avr/power.h **** functionality can be achieved through the XTAL Divide Control Register.
1381:/usr/lib/avr/include/avr/power.h **** Below are two macros and an enumerated type that can be used to
1382:/usr/lib/avr/include/avr/power.h **** interface to the Clock Prescale Register or
1383:/usr/lib/avr/include/avr/power.h **** XTAL Divide Control Register.
1384:/usr/lib/avr/include/avr/power.h **** 
1385:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices have a clock prescaler. On those devices
1386:/usr/lib/avr/include/avr/power.h **** without a Clock Prescale Register or XTAL Divide Control Register, these
1387:/usr/lib/avr/include/avr/power.h **** macros are not available.
1388:/usr/lib/avr/include/avr/power.h **** */
1389:/usr/lib/avr/include/avr/power.h **** 
1390:/usr/lib/avr/include/avr/power.h **** 
1391:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
1392:/usr/lib/avr/include/avr/power.h **** \code 
1393:/usr/lib/avr/include/avr/power.h **** typedef enum
1394:/usr/lib/avr/include/avr/power.h **** {
1395:/usr/lib/avr/include/avr/power.h ****     clock_div_1 = 0,
1396:/usr/lib/avr/include/avr/power.h ****     clock_div_2 = 1,
1397:/usr/lib/avr/include/avr/power.h ****     clock_div_4 = 2,
1398:/usr/lib/avr/include/avr/power.h ****     clock_div_8 = 3,
1399:/usr/lib/avr/include/avr/power.h ****     clock_div_16 = 4,
1400:/usr/lib/avr/include/avr/power.h ****     clock_div_32 = 5,
1401:/usr/lib/avr/include/avr/power.h ****     clock_div_64 = 6,
1402:/usr/lib/avr/include/avr/power.h ****     clock_div_128 = 7,
1403:/usr/lib/avr/include/avr/power.h ****     clock_div_256 = 8,
1404:/usr/lib/avr/include/avr/power.h ****     clock_div_1_rc = 15, // ATmega128RFA1 only
1405:/usr/lib/avr/include/avr/power.h **** } clock_div_t;
1406:/usr/lib/avr/include/avr/power.h **** \endcode
1407:/usr/lib/avr/include/avr/power.h **** Clock prescaler setting enumerations for device using
1408:/usr/lib/avr/include/avr/power.h **** System Clock Prescale Register.
1409:/usr/lib/avr/include/avr/power.h **** 
1410:/usr/lib/avr/include/avr/power.h **** \code
1411:/usr/lib/avr/include/avr/power.h **** typedef enum
1412:/usr/lib/avr/include/avr/power.h **** {
1413:/usr/lib/avr/include/avr/power.h ****     clock_div_1 = 1,
1414:/usr/lib/avr/include/avr/power.h ****     clock_div_2 = 2,
1415:/usr/lib/avr/include/avr/power.h ****     clock_div_4 = 4,
1416:/usr/lib/avr/include/avr/power.h ****     clock_div_8 = 8,
1417:/usr/lib/avr/include/avr/power.h ****     clock_div_16 = 16,
1418:/usr/lib/avr/include/avr/power.h ****     clock_div_32 = 32,
1419:/usr/lib/avr/include/avr/power.h ****     clock_div_64 = 64,
1420:/usr/lib/avr/include/avr/power.h ****     clock_div_128 = 128
1421:/usr/lib/avr/include/avr/power.h **** } clock_div_t;
1422:/usr/lib/avr/include/avr/power.h **** \endcode
1423:/usr/lib/avr/include/avr/power.h **** Clock prescaler setting enumerations for device using
1424:/usr/lib/avr/include/avr/power.h **** XTAL Divide Control Register.
1425:/usr/lib/avr/include/avr/power.h **** 
1426:/usr/lib/avr/include/avr/power.h **** */
1427:/usr/lib/avr/include/avr/power.h **** typedef enum
1428:/usr/lib/avr/include/avr/power.h **** {
1429:/usr/lib/avr/include/avr/power.h ****     clock_div_1 = 0,
1430:/usr/lib/avr/include/avr/power.h ****     clock_div_2 = 1,
1431:/usr/lib/avr/include/avr/power.h ****     clock_div_4 = 2,
1432:/usr/lib/avr/include/avr/power.h ****     clock_div_8 = 3,
1433:/usr/lib/avr/include/avr/power.h ****     clock_div_16 = 4,
1434:/usr/lib/avr/include/avr/power.h ****     clock_div_32 = 5,
1435:/usr/lib/avr/include/avr/power.h ****     clock_div_64 = 6,
1436:/usr/lib/avr/include/avr/power.h ****     clock_div_128 = 7,
1437:/usr/lib/avr/include/avr/power.h ****     clock_div_256 = 8
1438:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_ATmega128RFA1__) \
1439:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega256RFR2__) \
1440:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2564RFR2__) \
1441:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFR2__) \
1442:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284RFR2__) \
1443:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64RFR2__) \
1444:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644RFR2__)
1445:/usr/lib/avr/include/avr/power.h ****     , clock_div_1_rc = 15
1446:/usr/lib/avr/include/avr/power.h **** #endif
1447:/usr/lib/avr/include/avr/power.h **** } clock_div_t;
1448:/usr/lib/avr/include/avr/power.h **** 
1449:/usr/lib/avr/include/avr/power.h **** 
1450:/usr/lib/avr/include/avr/power.h **** static __inline__ void clock_prescale_set(clock_div_t) __attribute__((__always_inline__));
1451:/usr/lib/avr/include/avr/power.h **** 
1452:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
1453:/usr/lib/avr/include/avr/power.h **** \code clock_prescale_set(x) \endcode
1454:/usr/lib/avr/include/avr/power.h **** 
1455:/usr/lib/avr/include/avr/power.h **** Set the clock prescaler register select bits, selecting a system clock
1456:/usr/lib/avr/include/avr/power.h **** division setting. This function is inlined, even if compiler
1457:/usr/lib/avr/include/avr/power.h **** optimizations are disabled.
1458:/usr/lib/avr/include/avr/power.h **** 
1459:/usr/lib/avr/include/avr/power.h **** The type of \c x is \c clock_div_t.
1460:/usr/lib/avr/include/avr/power.h **** 
1461:/usr/lib/avr/include/avr/power.h **** \note For device with XTAL Divide Control Register (XDIV), \c x can actually range
1462:/usr/lib/avr/include/avr/power.h **** from 1 to 129. Thus, one does not need to use \c clock_div_t type as argument.
1463:/usr/lib/avr/include/avr/power.h **** */
1464:/usr/lib/avr/include/avr/power.h **** void clock_prescale_set(clock_div_t __x)
1465:/usr/lib/avr/include/avr/power.h **** {
1466:/usr/lib/avr/include/avr/power.h ****     uint8_t __tmp = _BV(CLKPCE);
1467:/usr/lib/avr/include/avr/power.h ****     __asm__ __volatile__ (
 570               		.loc 4 1467 0
 571 001c 90E0      		ldi r25,0
 572 001e 80E8      		ldi r24,lo8(-128)
 573               	/* #APP */
 574               	 ;  1467 "/usr/lib/avr/include/avr/power.h" 1
 575 0020 0FB6      		in __tmp_reg__,__SREG__
 576 0022 F894      		cli
 577 0024 8093 6100 		sts 97, r24
 578 0028 9093 6100 		sts 97, r25
 579 002c 0FBE      		out __SREG__, __tmp_reg__
 580               	 ;  0 "" 2
 581               	/* #NOAPP */
 582               	.LBE150:
 583               	.LBE149:
 130:BootloaderDFU.c **** 	MCUCR = (1 << IVSEL);
 584               		.loc 1 130 0
 585 002e 81E0      		ldi r24,lo8(1)
 586 0030 85BF      		out 0x35,r24
 131:BootloaderDFU.c **** 
 587               		.loc 1 131 0
 588 0032 82E0      		ldi r24,lo8(2)
 589 0034 85BF      		out 0x35,r24
 134:BootloaderDFU.c **** }
 590               		.loc 1 134 0
 591 0036 0C94 0000 		jmp USB_Init
 592               	.LVL31:
 593               		.cfi_endproc
 594               	.LFE75:
 596               		.section	.text.ResetHardware,"ax",@progbits
 597               	.global	ResetHardware
 599               	ResetHardware:
 600               	.LFB76:
 139:BootloaderDFU.c **** 	/* Shut down the USB subsystem */
 601               		.loc 1 139 0
 602               		.cfi_startproc
 603               	/* prologue: function */
 604               	/* frame size = 0 */
 605               	/* stack size = 0 */
 606               	.L__stack_usage = 0
 141:BootloaderDFU.c **** 
 607               		.loc 1 141 0
 608 0000 0E94 0000 		call USB_ShutDown
 609               	.LVL32:
 144:BootloaderDFU.c **** 	MCUCR = 0;
 610               		.loc 1 144 0
 611 0004 81E0      		ldi r24,lo8(1)
 612 0006 85BF      		out 0x35,r24
 145:BootloaderDFU.c **** }
 613               		.loc 1 145 0
 614 0008 15BE      		out 0x35,__zero_reg__
 615 000a 0895      		ret
 616               		.cfi_endproc
 617               	.LFE76:
 619               		.section	.text.startup.main,"ax",@progbits
 620               	.global	main
 622               	main:
 623               	.LFB74:
 101:BootloaderDFU.c **** 	/* Configure hardware required by the bootloader */
 624               		.loc 1 101 0
 625               		.cfi_startproc
 626               	/* prologue: function */
 627               	/* frame size = 0 */
 628               	/* stack size = 0 */
 629               	.L__stack_usage = 0
 103:BootloaderDFU.c **** 
 630               		.loc 1 103 0
 631 0000 0E94 0000 		call SetupHardware
 632               	.LVL33:
 106:BootloaderDFU.c **** 
 633               		.loc 1 106 0
 634               	/* #APP */
 635               	 ;  106 "BootloaderDFU.c" 1
 636 0004 7894      		sei
 637               	 ;  0 "" 2
 638               	/* #NOAPP */
 639               	.L54:
 109:BootloaderDFU.c **** 	  USB_USBTask();
 640               		.loc 1 109 0
 641 0006 8091 0000 		lds r24,RunBootloader
 642 000a 8823      		tst r24
 643 000c 01F0      		breq .L56
 644               	.L55:
 110:BootloaderDFU.c **** 
 645               		.loc 1 110 0
 646 000e 0E94 0000 		call USB_USBTask
 647               	.LVL34:
 648 0012 00C0      		rjmp .L54
 649               	.L56:
 109:BootloaderDFU.c **** 	  USB_USBTask();
 650               		.loc 1 109 0 discriminator 1
 651 0014 8091 0000 		lds r24,WaitForExit
 652 0018 8111      		cpse r24,__zero_reg__
 653 001a 00C0      		rjmp .L55
 113:BootloaderDFU.c **** 
 654               		.loc 1 113 0
 655 001c 0E94 0000 		call ResetHardware
 656               	.LVL35:
 116:BootloaderDFU.c **** }
 657               		.loc 1 116 0
 658 0020 E091 0000 		lds r30,AppStartPtr
 659 0024 F091 0000 		lds r31,AppStartPtr+1
 660 0028 0995      		icall
 661               	.LVL36:
 662               		.cfi_endproc
 663               	.LFE74:
 665               		.section	.text.EVENT_USB_Device_UnhandledControlRequest,"ax",@progbits
 666               	.global	EVENT_USB_Device_UnhandledControlRequest
 668               	EVENT_USB_Device_UnhandledControlRequest:
 669               	.LFB77:
 153:BootloaderDFU.c **** 	/* Get the size of the command and data from the wLength value */
 670               		.loc 1 153 0
 671               		.cfi_startproc
 672 0000 8F92      		push r8
 673               	.LCFI4:
 674               		.cfi_def_cfa_offset 3
 675               		.cfi_offset 8, -2
 676 0002 9F92      		push r9
 677               	.LCFI5:
 678               		.cfi_def_cfa_offset 4
 679               		.cfi_offset 9, -3
 680 0004 AF92      		push r10
 681               	.LCFI6:
 682               		.cfi_def_cfa_offset 5
 683               		.cfi_offset 10, -4
 684 0006 BF92      		push r11
 685               	.LCFI7:
 686               		.cfi_def_cfa_offset 6
 687               		.cfi_offset 11, -5
 688 0008 CF92      		push r12
 689               	.LCFI8:
 690               		.cfi_def_cfa_offset 7
 691               		.cfi_offset 12, -6
 692 000a DF92      		push r13
 693               	.LCFI9:
 694               		.cfi_def_cfa_offset 8
 695               		.cfi_offset 13, -7
 696 000c EF92      		push r14
 697               	.LCFI10:
 698               		.cfi_def_cfa_offset 9
 699               		.cfi_offset 14, -8
 700 000e FF92      		push r15
 701               	.LCFI11:
 702               		.cfi_def_cfa_offset 10
 703               		.cfi_offset 15, -9
 704 0010 1F93      		push r17
 705               	.LCFI12:
 706               		.cfi_def_cfa_offset 11
 707               		.cfi_offset 17, -10
 708 0012 CF93      		push r28
 709               	.LCFI13:
 710               		.cfi_def_cfa_offset 12
 711               		.cfi_offset 28, -11
 712 0014 DF93      		push r29
 713               	.LCFI14:
 714               		.cfi_def_cfa_offset 13
 715               		.cfi_offset 29, -12
 716               	/* prologue: function */
 717               	/* frame size = 0 */
 718               	/* stack size = 11 */
 719               	.L__stack_usage = 11
 155:BootloaderDFU.c **** 
 720               		.loc 1 155 0
 721 0016 8091 0000 		lds r24,USB_ControlRequest+6
 722 001a 9091 0000 		lds r25,USB_ControlRequest+6+1
 723 001e 9093 0000 		sts SentCommand+6+1,r25
 724 0022 8093 0000 		sts SentCommand+6,r24
 157:BootloaderDFU.c **** 	{
 725               		.loc 1 157 0
 726 0026 8091 0000 		lds r24,USB_ControlRequest+1
 727 002a 8330      		cpi r24,lo8(3)
 728 002c 01F4      		brne .+2
 729 002e 00C0      		rjmp .L59
 730 0030 00F4      		brsh .L60
 731 0032 8130      		cpi r24,lo8(1)
 732 0034 01F0      		breq .L61
 733 0036 8230      		cpi r24,lo8(2)
 734 0038 01F0      		breq .+2
 735 003a 00C0      		rjmp .L57
 736               	.LBB151:
 737               	.LBB152:
 494:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 738               		.loc 2 494 0
 739 003c 8091 E800 		lds r24,232
 740 0040 877F      		andi r24,lo8(-9)
 741 0042 8093 E800 		sts 232,r24
 742 0046 00C0      		rjmp .L97
 743               	.L60:
 744               	.LBE152:
 745               	.LBE151:
 157:BootloaderDFU.c **** 	{
 746               		.loc 1 157 0
 747 0048 8530      		cpi r24,lo8(5)
 748 004a 01F4      		brne .+2
 749 004c 00C0      		rjmp .L63
 750 004e 00F4      		brsh .+2
 751 0050 00C0      		rjmp .L64
 752 0052 8630      		cpi r24,lo8(6)
 753 0054 01F0      		breq .+2
 754 0056 00C0      		rjmp .L57
 755               	.LBB153:
 756               	.LBB154:
 494:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 757               		.loc 2 494 0
 758 0058 8091 E800 		lds r24,232
 759 005c 877F      		andi r24,lo8(-9)
 760 005e 8093 E800 		sts 232,r24
 761               	.LBE154:
 762               	.LBE153:
 453:BootloaderDFU.c **** 
 763               		.loc 1 453 0
 764 0062 82E0      		ldi r24,lo8(2)
 765 0064 8093 0000 		sts DFU_State,r24
 766 0068 00C0      		rjmp .L151
 767               	.L61:
 768               	.LBB155:
 769               	.LBB156:
 494:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 770               		.loc 2 494 0
 771 006a 8091 E800 		lds r24,232
 772 006e 877F      		andi r24,lo8(-9)
 773 0070 8093 E800 		sts 232,r24
 774               	.LBE156:
 775               	.LBE155:
 163:BootloaderDFU.c **** 			{
 776               		.loc 1 163 0
 777 0074 8091 0000 		lds r24,WaitForExit
 778 0078 8823      		tst r24
 779 007a 01F0      		breq .L66
 166:BootloaderDFU.c **** 
 780               		.loc 1 166 0
 781 007c 0E94 0000 		call ProcessBootloaderCommand
 782               	.LVL37:
 169:BootloaderDFU.c **** 			}
 783               		.loc 1 169 0
 784 0080 1092 0000 		sts WaitForExit,__zero_reg__
 785               	.L66:
 173:BootloaderDFU.c **** 			{
 786               		.loc 1 173 0
 787 0084 8091 0000 		lds r24,SentCommand+6
 788 0088 9091 0000 		lds r25,SentCommand+6+1
 789 008c 0097      		sbiw r24,0
 790 008e 01F0      		breq .L68
 791               	.L136:
 792               	.LBB157:
 793               	.LBB158:
 469:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 794               		.loc 2 469 0
 795 0090 2091 E800 		lds r18,232
 796               	.LBE158:
 797               	.LBE157:
 175:BootloaderDFU.c **** 				{
 798               		.loc 1 175 0
 799 0094 22FD      		sbrc r18,2
 800 0096 00C0      		rjmp .L153
 177:BootloaderDFU.c **** 					  return;
 801               		.loc 1 177 0
 802 0098 2EB3      		in r18,0x1e
 803 009a 2111      		cpse r18,__zero_reg__
 804 009c 00C0      		rjmp .L136
 805 009e 00C0      		rjmp .L57
 806               	.L153:
 807               	.LBB159:
 808               	.LBB160:
 602:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 809               		.loc 2 602 0
 810 00a0 2091 F100 		lds r18,241
 811               	.LBE160:
 812               	.LBE159:
 182:BootloaderDFU.c **** 
 813               		.loc 1 182 0
 814 00a4 2093 0000 		sts SentCommand,r18
 185:BootloaderDFU.c **** 
 815               		.loc 1 185 0
 816 00a8 0197      		sbiw r24,1
 817 00aa 9093 0000 		sts SentCommand+6+1,r25
 818 00ae 8093 0000 		sts SentCommand+6,r24
 819               	.LVL38:
 820 00b2 E0E0      		ldi r30,lo8(SentCommand+1)
 821 00b4 F0E0      		ldi r31,hi8(SentCommand+1)
 822 00b6 25E0      		ldi r18,lo8(5)
 823 00b8 2E0F      		add r18,r30
 824               	.LVL39:
 825               	.L70:
 826               	.LBB161:
 827               	.LBB162:
 828               	.LBB163:
 314:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#elif defined(USB_SERIES_4_AVR)
 829               		.loc 2 314 0
 830 00ba 8091 F200 		lds r24,242
 831 00be 9091 F300 		lds r25,242+1
 832               	.LBE163:
 833               	.LBE162:
 188:BootloaderDFU.c **** 				     Endpoint_BytesInEndpoint(); DataByte++)
 834               		.loc 1 188 0
 835 00c2 892B      		or r24,r25
 836 00c4 01F0      		breq .L72
 837               	.LBB164:
 838               	.LBB165:
 602:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 839               		.loc 2 602 0
 840 00c6 8091 F100 		lds r24,241
 841               	.LBE165:
 842               	.LBE164:
 191:BootloaderDFU.c **** 					SentCommand.DataSize--;
 843               		.loc 1 191 0
 844 00ca 8193      		st Z+,r24
 845               	.LVL40:
 192:BootloaderDFU.c **** 				}
 846               		.loc 1 192 0
 847 00cc 8091 0000 		lds r24,SentCommand+6
 848 00d0 9091 0000 		lds r25,SentCommand+6+1
 849 00d4 0197      		sbiw r24,1
 850 00d6 9093 0000 		sts SentCommand+6+1,r25
 851 00da 8093 0000 		sts SentCommand+6,r24
 852               	.LVL41:
 188:BootloaderDFU.c **** 				     Endpoint_BytesInEndpoint(); DataByte++)
 853               		.loc 1 188 0
 854 00de 2E13      		cpse r18,r30
 855 00e0 00C0      		rjmp .L70
 856               	.LVL42:
 857               	.L72:
 858               	.LBE161:
 196:BootloaderDFU.c **** 			}
 859               		.loc 1 196 0
 860 00e2 0E94 0000 		call ProcessBootloaderCommand
 861               	.LVL43:
 862               	.L68:
 200:BootloaderDFU.c **** 			{
 863               		.loc 1 200 0
 864 00e6 8091 0000 		lds r24,DFU_State
 865 00ea 8530      		cpi r24,lo8(5)
 866 00ec 01F0      		breq .+2
 867 00ee 00C0      		rjmp .L73
 202:BootloaderDFU.c **** 				{
 868               		.loc 1 202 0
 869 00f0 8091 0000 		lds r24,SentCommand+6
 870 00f4 9091 0000 		lds r25,SentCommand+6+1
 871 00f8 892B      		or r24,r25
 872 00fa 01F4      		brne .L74
 204:BootloaderDFU.c **** 				}
 873               		.loc 1 204 0
 874 00fc 82E0      		ldi r24,lo8(2)
 875 00fe 8093 0000 		sts DFU_State,r24
 876 0102 00C0      		rjmp .L73
 877               	.L74:
 878               	.LBB166:
 209:BootloaderDFU.c **** 
 879               		.loc 1 209 0
 880 0104 8AE1      		ldi r24,lo8(26)
 881 0106 0E94 0000 		call DiscardFillerBytes
 882               	.LVL44:
 212:BootloaderDFU.c **** 
 883               		.loc 1 212 0
 884 010a 8091 0000 		lds r24,StartAddr
 885 010e 8F71      		andi r24,lo8(31)
 886 0110 0E94 0000 		call DiscardFillerBytes
 887               	.LVL45:
 215:BootloaderDFU.c **** 
 888               		.loc 1 215 0
 889 0114 2091 0000 		lds r18,StartAddr
 890 0118 3091 0000 		lds r19,StartAddr+1
 891 011c 8091 0000 		lds r24,EndAddr
 892 0120 9091 0000 		lds r25,EndAddr+1
 893 0124 0196      		adiw r24,1
 894 0126 EC01      		movw r28,r24
 895 0128 C21B      		sub r28,r18
 896 012a D30B      		sbc r29,r19
 897               	.LVL46:
 217:BootloaderDFU.c **** 					{
 898               		.loc 1 217 0
 899 012c 8091 0000 		lds r24,SentCommand+1
 900 0130 8111      		cpse r24,__zero_reg__
 901 0132 00C0      		rjmp .L76
 902               	.LBB167:
 220:BootloaderDFU.c **** 
 903               		.loc 1 220 0
 904 0134 CE01      		movw r24,r28
 905 0136 9695      		lsr r25
 906 0138 8795      		ror r24
 907               	.LVL47:
 226:BootloaderDFU.c **** 
 908               		.loc 1 226 0
 909 013a A901      		movw r20,r18
 910               	.LVL48:
 911 013c 2091 0000 		lds r18,Flash64KBPage
 912 0140 622F      		mov r22,r18
 913 0142 70E0      		ldi r23,0
 914               	.LVL49:
 228:BootloaderDFU.c **** 						uint8_t  WordsInFlashPage          = 0;
 915               		.loc 1 228 0
 916 0144 4A01      		movw r8,r20
 917 0146 5B01      		movw r10,r22
 918               	.LVL50:
 229:BootloaderDFU.c **** 
 919               		.loc 1 229 0
 920 0148 20E0      		ldi r18,0
 246:BootloaderDFU.c **** 
 921               		.loc 1 246 0
 922 014a C1E0      		ldi r28,lo8(1)
 923               	.LVL51:
 256:BootloaderDFU.c **** 								boot_spm_busy_wait();
 924               		.loc 1 256 0
 925 014c D5E0      		ldi r29,lo8(5)
 266:BootloaderDFU.c **** 									boot_spm_busy_wait();
 926               		.loc 1 266 0
 927 014e 13E0      		ldi r17,lo8(3)
 928               	.LVL52:
 929               	.L77:
 231:BootloaderDFU.c **** 						{
 930               		.loc 1 231 0
 931 0150 0097      		sbiw r24,0
 932 0152 01F4      		brne .+2
 933 0154 00C0      		rjmp .L154
 934               	.LBB168:
 935               	.LBB169:
 314:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#elif defined(USB_SERIES_4_AVR)
 936               		.loc 2 314 0
 937 0156 E091 F200 		lds r30,242
 938 015a F091 F300 		lds r31,242+1
 939               	.LBE169:
 940               	.LBE168:
 234:BootloaderDFU.c **** 							{
 941               		.loc 1 234 0
 942 015e EF2B      		or r30,r31
 943 0160 01F0      		breq .L78
 944               	.L84:
 231:BootloaderDFU.c **** 						{
 945               		.loc 1 231 0
 946 0162 0197      		sbiw r24,1
 947               	.LVL53:
 948               	.LBB170:
 949               	.LBB171:
 627:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 628:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 629:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Reads two bytes from the currently selected endpoint's bank in little endian format, for OUT
 630:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  direction endpoints.
 631:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 632:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 633:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 634:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Next word in the currently selected endpoint's FIFO buffer.
 635:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 636:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint16_t Endpoint_Read_Word_LE(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 637:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint16_t Endpoint_Read_Word_LE(void)
 638:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 639:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				union
 640:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				{
 641:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					uint16_t Word;
 642:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					uint8_t  Bytes[2];
 643:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				} Data;
 644:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 645:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Data.Bytes[0] = UEDATX;
 950               		.loc 2 645 0
 951 0164 E091 F100 		lds r30,241
 646:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Data.Bytes[1] = UEDATX;
 952               		.loc 2 646 0
 953 0168 3091 F100 		lds r19,241
 647:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 648:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return Data.Word;
 954               		.loc 2 648 0
 955 016c AE2F      		mov r26,r30
 956 016e B32F      		mov r27,r19
 957               	.LBE171:
 958               	.LBE170:
 246:BootloaderDFU.c **** 
 959               		.loc 1 246 0
 960               	/* #APP */
 961               	 ;  246 "BootloaderDFU.c" 1
 962 0170 0D01      		movw  r0, r26
 963 0172 FA01      		movw r30, r20
 964 0174 6093 5B00 		sts 91, r22
 965 0178 C093 5700 		sts 87, r28
 966 017c E895      		spm
 967 017e 1124      		clr  r1
 968               		
 969               	 ;  0 "" 2
 249:BootloaderDFU.c **** 							CurrFlashAddress.Long += 2;
 970               		.loc 1 249 0
 971               	/* #NOAPP */
 972 0180 2F5F      		subi r18,lo8(-(1))
 973               	.LVL54:
 250:BootloaderDFU.c **** 
 974               		.loc 1 250 0
 975 0182 6A01      		movw r12,r20
 976 0184 7B01      		movw r14,r22
 977 0186 32E0      		ldi r19,2
 978 0188 C30E      		add r12,r19
 979 018a D11C      		adc r13,__zero_reg__
 980 018c E11C      		adc r14,__zero_reg__
 981 018e F11C      		adc r15,__zero_reg__
 982 0190 B701      		movw r22,r14
 983 0192 A601      		movw r20,r12
 984               	.LVL55:
 253:BootloaderDFU.c **** 							{
 985               		.loc 1 253 0
 986 0194 2038      		cpi r18,lo8(-128)
 987 0196 01F4      		brne .L149
 988 0198 00C0      		rjmp .L79
 989               	.LVL56:
 990               	.L78:
 991               	.LBB172:
 992               	.LBB173:
 523:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif
 993               		.loc 2 523 0
 994 019a 3091 E800 		lds r19,232
 995 019e 3B7F      		andi r19,lo8(-5)
 996 01a0 3093 E800 		sts 232,r19
 997               	.L81:
 998               	.LBE173:
 999               	.LBE172:
 1000               	.LBB174:
 1001               	.LBB175:
 469:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 1002               		.loc 2 469 0
 1003 01a4 3091 E800 		lds r19,232
 1004               	.LBE175:
 1005               	.LBE174:
 238:BootloaderDFU.c **** 								{
 1006               		.loc 1 238 0
 1007 01a8 32FD      		sbrc r19,2
 1008 01aa 00C0      		rjmp .L84
 240:BootloaderDFU.c **** 									  return;
 1009               		.loc 1 240 0
 1010 01ac 3EB3      		in r19,0x1e
 1011 01ae 3111      		cpse r19,__zero_reg__
 1012 01b0 00C0      		rjmp .L81
 1013 01b2 00C0      		rjmp .L57
 1014               	.LVL57:
 1015               	.L149:
 253:BootloaderDFU.c **** 							{
 1016               		.loc 1 253 0 discriminator 1
 1017 01b4 0097      		sbiw r24,0
 1018 01b6 01F4      		brne .L77
 1019               	.L79:
 256:BootloaderDFU.c **** 								boot_spm_busy_wait();
 1020               		.loc 1 256 0
 1021               	/* #APP */
 1022               	 ;  256 "BootloaderDFU.c" 1
 1023 01b8 F401      		movw r30, r8
 1024 01ba A092 5B00 		sts 91, r10
 1025 01be D093 5700 		sts 87, r29
 1026 01c2 E895      		spm
 1027               		
 1028               	 ;  0 "" 2
 1029               	/* #NOAPP */
 1030               	.L86:
 257:BootloaderDFU.c **** 
 1031               		.loc 1 257 0 discriminator 1
 1032 01c4 07B6      		in __tmp_reg__,0x37
 1033 01c6 00FC      		sbrc __tmp_reg__,0
 1034 01c8 00C0      		rjmp .L86
 260:BootloaderDFU.c **** 								{
 1035               		.loc 1 260 0
 1036 01ca 0097      		sbiw r24,0
 1037 01cc 01F4      		brne .+2
 1038 01ce 00C0      		rjmp .L77
 1039               	.LVL58:
 266:BootloaderDFU.c **** 									boot_spm_busy_wait();
 1040               		.loc 1 266 0
 1041               	/* #APP */
 1042               	 ;  266 "BootloaderDFU.c" 1
 1043 01d0 F601      		movw r30, r12
 1044 01d2 E092 5B00 		sts  91, r14
 1045 01d6 1093 5700 		sts 87, r17
 1046 01da E895      		spm
 1047               		
 1048               	 ;  0 "" 2
 1049               	/* #NOAPP */
 1050               	.L87:
 267:BootloaderDFU.c **** 								}
 1051               		.loc 1 267 0 discriminator 1
 1052 01dc 07B6      		in __tmp_reg__,0x37
 1053 01de 00FC      		sbrc __tmp_reg__,0
 1054 01e0 00C0      		rjmp .L87
 262:BootloaderDFU.c **** 									WordsInFlashPage          = 0;
 1055               		.loc 1 262 0
 1056 01e2 4601      		movw r8,r12
 1057 01e4 5701      		movw r10,r14
 263:BootloaderDFU.c **** 
 1058               		.loc 1 263 0
 1059 01e6 20E0      		ldi r18,0
 1060 01e8 00C0      		rjmp .L77
 1061               	.LVL59:
 1062               	.L154:
 273:BootloaderDFU.c **** 
 1063               		.loc 1 273 0
 1064 01ea 8091 0000 		lds r24,EndAddr
 1065 01ee 9091 0000 		lds r25,EndAddr+1
 1066               	.LVL60:
 1067 01f2 9093 0000 		sts StartAddr+1,r25
 1068 01f6 8093 0000 		sts StartAddr,r24
 276:BootloaderDFU.c **** 					}
 1069               		.loc 1 276 0
 1070 01fa 81E1      		ldi r24,lo8(17)
 1071               	/* #APP */
 1072               	 ;  276 "BootloaderDFU.c" 1
 1073 01fc 8093 5700 		sts 87, r24
 1074 0200 E895      		spm
 1075               		
 1076               	 ;  0 "" 2
 1077               	/* #NOAPP */
 1078               	.LBE167:
 1079 0202 00C0      		rjmp .L89
 1080               	.LVL61:
 1081               	.L96:
 1082               	.LBB176:
 1083               	.LBB177:
 314:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#elif defined(USB_SERIES_4_AVR)
 1084               		.loc 2 314 0
 1085 0204 8091 F200 		lds r24,242
 1086 0208 9091 F300 		lds r25,242+1
 1087               	.LBE177:
 1088               	.LBE176:
 283:BootloaderDFU.c **** 							{
 1089               		.loc 1 283 0
 1090 020c 892B      		or r24,r25
 1091 020e 01F0      		breq .L90
 1092               	.L95:
 1093               	.LBB178:
 1094               	.LBB179:
 602:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 1095               		.loc 2 602 0
 1096 0210 6091 F100 		lds r22,241
 1097               	.LBE179:
 1098               	.LBE178:
 280:BootloaderDFU.c **** 						{
 1099               		.loc 1 280 0
 1100 0214 2197      		sbiw r28,1
 1101               	.LVL62:
 295:BootloaderDFU.c **** 
 1102               		.loc 1 295 0
 1103 0216 8091 0000 		lds r24,StartAddr
 1104 021a 9091 0000 		lds r25,StartAddr+1
 1105 021e 0E94 0000 		call eeprom_write_byte
 1106               	.LVL63:
 298:BootloaderDFU.c **** 						}
 1107               		.loc 1 298 0
 1108 0222 8091 0000 		lds r24,StartAddr
 1109 0226 9091 0000 		lds r25,StartAddr+1
 1110 022a 0196      		adiw r24,1
 1111 022c 9093 0000 		sts StartAddr+1,r25
 1112 0230 8093 0000 		sts StartAddr,r24
 1113               	.LVL64:
 1114               	.L76:
 280:BootloaderDFU.c **** 						{
 1115               		.loc 1 280 0
 1116 0234 2097      		sbiw r28,0
 1117 0236 01F4      		brne .L96
 1118 0238 00C0      		rjmp .L89
 1119               	.L90:
 1120               	.LBB180:
 1121               	.LBB181:
 523:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif
 1122               		.loc 2 523 0
 1123 023a 8091 E800 		lds r24,232
 1124 023e 8B7F      		andi r24,lo8(-5)
 1125 0240 8093 E800 		sts 232,r24
 1126               	.L92:
 1127               	.LBE181:
 1128               	.LBE180:
 1129               	.LBB182:
 1130               	.LBB183:
 469:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 1131               		.loc 2 469 0
 1132 0244 8091 E800 		lds r24,232
 1133               	.LBE183:
 1134               	.LBE182:
 287:BootloaderDFU.c **** 								{
 1135               		.loc 1 287 0
 1136 0248 82FD      		sbrc r24,2
 1137 024a 00C0      		rjmp .L95
 289:BootloaderDFU.c **** 									  return;
 1138               		.loc 1 289 0
 1139 024c 8EB3      		in r24,0x1e
 1140 024e 8111      		cpse r24,__zero_reg__
 1141 0250 00C0      		rjmp .L92
 1142 0252 00C0      		rjmp .L57
 1143               	.LVL65:
 1144               	.L89:
 303:BootloaderDFU.c **** 				}
 1145               		.loc 1 303 0
 1146 0254 80E1      		ldi r24,lo8(16)
 1147 0256 0E94 0000 		call DiscardFillerBytes
 1148               	.LVL66:
 1149               	.L73:
 1150               	.LBE166:
 1151               	.LBB184:
 1152               	.LBB185:
 523:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif
 1153               		.loc 2 523 0
 1154 025a 8091 E800 		lds r24,232
 1155 025e 8B7F      		andi r24,lo8(-5)
 1156 0260 00C0      		rjmp .L152
 1157               	.L98:
 1158               	.LBE185:
 1159               	.LBE184:
 317:BootloaderDFU.c **** 				  return;
 1160               		.loc 1 317 0
 1161 0262 8EB3      		in r24,0x1e
 1162 0264 8823      		tst r24
 1163 0266 01F4      		brne .+2
 1164 0268 00C0      		rjmp .L57
 1165               	.L97:
 1166               	.LBB186:
 1167               	.LBB187:
 457:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 1168               		.loc 2 457 0
 1169 026a 8091 E800 		lds r24,232
 1170               	.LBE187:
 1171               	.LBE186:
 315:BootloaderDFU.c **** 			{
 1172               		.loc 1 315 0
 1173 026e 80FF      		sbrs r24,0
 1174 0270 00C0      		rjmp .L98
 321:BootloaderDFU.c **** 			{
 1175               		.loc 1 321 0
 1176 0272 8091 0000 		lds r24,DFU_State
 1177 0276 8930      		cpi r24,lo8(9)
 1178 0278 01F0      		breq .L99
 323:BootloaderDFU.c **** 				{
 1179               		.loc 1 323 0
 1180 027a 8A30      		cpi r24,lo8(10)
 1181 027c 01F4      		brne .L100
 323:BootloaderDFU.c **** 				{
 1182               		.loc 1 323 0 is_stmt 0 discriminator 1
 1183 027e 8091 0000 		lds r24,SentCommand+1
 1184 0282 8130      		cpi r24,lo8(1)
 1185 0284 01F4      		brne .L100
 327:BootloaderDFU.c **** 				}
 1186               		.loc 1 327 0 is_stmt 1
 1187 0286 9091 0000 		lds r25,StartAddr
 1188 028a 8091 0000 		lds r24,StartAddr+1
 1189               	.LVL67:
 1190               	.LBB188:
 1191               	.LBB189:
 649:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 650:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 651:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Reads two bytes from the currently selected endpoint's bank in big endian format, for OUT
 652:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  direction endpoints.
 653:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 654:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 655:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 656:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Next word in the currently selected endpoint's FIFO buffer.
 657:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 658:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint16_t Endpoint_Read_Word_BE(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 659:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint16_t Endpoint_Read_Word_BE(void)
 660:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 661:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				union
 662:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				{
 663:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					uint16_t Word;
 664:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					uint8_t  Bytes[2];
 665:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				} Data;
 666:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 667:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Data.Bytes[1] = UEDATX;
 668:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Data.Bytes[0] = UEDATX;
 669:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 670:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return Data.Word;
 671:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 672:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 673:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Writes two bytes to the currently selected endpoint's bank in little endian format, for IN
 674:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  direction endpoints.
 675:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 676:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 677:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 678:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Word  Next word to write to the currently selected endpoint's FIFO buffer.
 679:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 680:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Write_Word_LE(const uint16_t Word) ATTR_ALWAYS_INLINE;
 681:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Write_Word_LE(const uint16_t Word)
 682:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 683:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEDATX = (Word & 0xFF);
 1192               		.loc 2 683 0
 1193 028e 9093 F100 		sts 241,r25
 1194 0292 00C0      		rjmp .L150
 1195               	.LVL68:
 1196               	.L100:
 1197               	.LBE189:
 1198               	.LBE188:
 332:BootloaderDFU.c **** 				}
 1199               		.loc 1 332 0
 1200 0294 8091 0000 		lds r24,ResponseByte
 1201               	.L150:
 1202               	.LVL69:
 1203               	.LBB190:
 1204               	.LBB191:
 614:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 1205               		.loc 2 614 0
 1206 0298 8093 F100 		sts 241,r24
 1207 029c 00C0      		rjmp .L101
 1208               	.LVL70:
 1209               	.L99:
 1210               	.LBE191:
 1211               	.LBE190:
 1212               	.LBB192:
 338:BootloaderDFU.c **** 
 1213               		.loc 1 338 0
 1214 029e 2091 0000 		lds r18,StartAddr
 1215 02a2 3091 0000 		lds r19,StartAddr+1
 1216 02a6 C091 0000 		lds r28,EndAddr
 1217 02aa D091 0000 		lds r29,EndAddr+1
 1218 02ae 2196      		adiw r28,1
 1219 02b0 C21B      		sub r28,r18
 1220 02b2 D30B      		sbc r29,r19
 1221               	.LVL71:
 340:BootloaderDFU.c **** 				{
 1222               		.loc 1 340 0
 1223 02b4 8091 0000 		lds r24,SentCommand+1
 1224 02b8 8111      		cpse r24,__zero_reg__
 1225 02ba 00C0      		rjmp .L102
 1226               	.LBB193:
 343:BootloaderDFU.c **** 
 1227               		.loc 1 343 0
 1228 02bc D695      		lsr r29
 1229 02be C795      		ror r28
 1230               	.LVL72:
 349:BootloaderDFU.c **** 
 1231               		.loc 1 349 0
 1232 02c0 C901      		movw r24,r18
 1233               	.LVL73:
 1234 02c2 2091 0000 		lds r18,Flash64KBPage
 1235               	.LVL74:
 1236 02c6 A22F      		mov r26,r18
 1237 02c8 B0E0      		ldi r27,0
 1238               	.LVL75:
 1239               	.L103:
 351:BootloaderDFU.c **** 					{
 1240               		.loc 1 351 0
 1241               	.LVL76:
 1242 02ca 2197      		sbiw r28,1
 1243 02cc 00F0      		brcs .L155
 1244               	.LBB194:
 1245               	.LBB195:
 314:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#elif defined(USB_SERIES_4_AVR)
 1246               		.loc 2 314 0
 1247 02ce 2091 F200 		lds r18,242
 1248 02d2 3091 F300 		lds r19,242+1
 1249               	.LBE195:
 1250               	.LBE194:
 354:BootloaderDFU.c **** 						{
 1251               		.loc 1 354 0
 1252 02d6 2032      		cpi r18,32
 1253 02d8 3105      		cpc r19,__zero_reg__
 1254 02da 01F0      		breq .L104
 1255               	.L109:
 1256               	.LVL77:
 1257               	.LBB196:
 367:BootloaderDFU.c **** 						#else
 1258               		.loc 1 367 0
 1259               	/* #APP */
 1260               	 ;  367 "BootloaderDFU.c" 1
 1261 02dc ABBF      		out 59, r26
 1262 02de FC01      		movw r30, r24
 1263 02e0 2791      		elpm r18, Z+
 1264 02e2 3691      		elpm r19, Z
 1265               		
 1266               	 ;  0 "" 2
 1267               	.LVL78:
 1268               	/* #NOAPP */
 1269               	.LBE196:
 1270               	.LBB197:
 1271               	.LBB198:
 1272               		.loc 2 683 0
 1273 02e4 2093 F100 		sts 241,r18
 684:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEDATX = (Word >> 8);
 1274               		.loc 2 684 0
 1275 02e8 3093 F100 		sts 241,r19
 1276               	.LBE198:
 1277               	.LBE197:
 373:BootloaderDFU.c **** 					}
 1278               		.loc 1 373 0
 1279 02ec 0296      		adiw r24,2
 1280 02ee A11D      		adc r26,__zero_reg__
 1281 02f0 B11D      		adc r27,__zero_reg__
 1282               	.LVL79:
 1283 02f2 00C0      		rjmp .L103
 1284               	.LVL80:
 1285               	.L104:
 1286               	.LBB199:
 1287               	.LBB200:
 508:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif
 1288               		.loc 2 508 0
 1289 02f4 2091 E800 		lds r18,232
 1290 02f8 2E7F      		andi r18,lo8(-2)
 1291 02fa 2093 E800 		sts 232,r18
 1292               	.L106:
 1293               	.LBE200:
 1294               	.LBE199:
 1295               	.LBB201:
 1296               	.LBB202:
 457:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 1297               		.loc 2 457 0
 1298 02fe 2091 E800 		lds r18,232
 1299               	.LBE202:
 1300               	.LBE201:
 358:BootloaderDFU.c **** 							{
 1301               		.loc 1 358 0
 1302 0302 20FD      		sbrc r18,0
 1303 0304 00C0      		rjmp .L109
 360:BootloaderDFU.c **** 								  return;
 1304               		.loc 1 360 0
 1305 0306 2EB3      		in r18,0x1e
 1306 0308 2111      		cpse r18,__zero_reg__
 1307 030a 00C0      		rjmp .L106
 1308 030c 00C0      		rjmp .L57
 1309               	.L155:
 377:BootloaderDFU.c **** 				}
 1310               		.loc 1 377 0
 1311 030e 8091 0000 		lds r24,EndAddr
 1312 0312 9091 0000 		lds r25,EndAddr+1
 1313 0316 9093 0000 		sts StartAddr+1,r25
 1314 031a 8093 0000 		sts StartAddr,r24
 1315               	.LBE193:
 1316 031e 00C0      		rjmp .L111
 1317               	.LVL81:
 1318               	.L102:
 379:BootloaderDFU.c **** 				{
 1319               		.loc 1 379 0
 1320 0320 8230      		cpi r24,lo8(2)
 1321 0322 01F4      		brne .L111
 1322               	.LVL82:
 1323               	.L113:
 381:BootloaderDFU.c **** 					{
 1324               		.loc 1 381 0
 1325 0324 2097      		sbiw r28,0
 1326 0326 01F0      		breq .L111
 1327               	.LBB203:
 1328               	.LBB204:
 314:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#elif defined(USB_SERIES_4_AVR)
 1329               		.loc 2 314 0
 1330 0328 8091 F200 		lds r24,242
 1331 032c 9091 F300 		lds r25,242+1
 1332               	.LBE204:
 1333               	.LBE203:
 384:BootloaderDFU.c **** 						{
 1334               		.loc 1 384 0
 1335 0330 8097      		sbiw r24,32
 1336 0332 01F0      		breq .L114
 1337               	.L118:
 396:BootloaderDFU.c **** 
 1338               		.loc 1 396 0
 1339 0334 8091 0000 		lds r24,StartAddr
 1340 0338 9091 0000 		lds r25,StartAddr+1
 1341 033c 0E94 0000 		call eeprom_read_byte
 1342               	.LVL83:
 1343               	.LBB205:
 1344               	.LBB206:
 614:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 1345               		.loc 2 614 0
 1346 0340 8093 F100 		sts 241,r24
 1347               	.LBE206:
 1348               	.LBE205:
 399:BootloaderDFU.c **** 					}
 1349               		.loc 1 399 0
 1350 0344 8091 0000 		lds r24,StartAddr
 1351 0348 9091 0000 		lds r25,StartAddr+1
 1352               	.LVL84:
 1353 034c 0196      		adiw r24,1
 1354 034e 9093 0000 		sts StartAddr+1,r25
 1355 0352 8093 0000 		sts StartAddr,r24
 1356               	.LVL85:
 1357 0356 2197      		sbiw r28,1
 1358               	.LVL86:
 1359 0358 00C0      		rjmp .L113
 1360               	.LVL87:
 1361               	.L114:
 1362               	.LBB207:
 1363               	.LBB208:
 508:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif
 1364               		.loc 2 508 0
 1365 035a 8091 E800 		lds r24,232
 1366 035e 8E7F      		andi r24,lo8(-2)
 1367 0360 8093 E800 		sts 232,r24
 1368               	.L116:
 1369               	.LBE208:
 1370               	.LBE207:
 1371               	.LBB209:
 1372               	.LBB210:
 457:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 1373               		.loc 2 457 0
 1374 0364 8091 E800 		lds r24,232
 1375               	.LBE210:
 1376               	.LBE209:
 388:BootloaderDFU.c **** 							{
 1377               		.loc 1 388 0
 1378 0368 80FD      		sbrc r24,0
 1379 036a 00C0      		rjmp .L118
 390:BootloaderDFU.c **** 								  return;
 1380               		.loc 1 390 0
 1381 036c 8EB3      		in r24,0x1e
 1382 036e 8111      		cpse r24,__zero_reg__
 1383 0370 00C0      		rjmp .L116
 1384 0372 00C0      		rjmp .L57
 1385               	.LVL88:
 1386               	.L111:
 404:BootloaderDFU.c **** 			}
 1387               		.loc 1 404 0
 1388 0374 82E0      		ldi r24,lo8(2)
 1389 0376 8093 0000 		sts DFU_State,r24
 1390               	.L101:
 1391               	.LBE192:
 1392               	.LBB211:
 1393               	.LBB212:
 508:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif
 1394               		.loc 2 508 0
 1395 037a 8091 E800 		lds r24,232
 1396 037e 8E7F      		andi r24,lo8(-2)
 1397               	.L152:
 1398 0380 8093 E800 		sts 232,r24
 1399 0384 00C0      		rjmp .L151
 1400               	.L59:
 1401               	.LBE212:
 1402               	.LBE211:
 1403               	.LBB213:
 1404               	.LBB214:
 494:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 1405               		.loc 2 494 0
 1406 0386 8091 E800 		lds r24,232
 1407 038a 877F      		andi r24,lo8(-9)
 1408 038c 8093 E800 		sts 232,r24
 1409               	.LBE214:
 1410               	.LBE213:
 415:BootloaderDFU.c **** 
 1411               		.loc 1 415 0
 1412 0390 8091 0000 		lds r24,DFU_Status
 1413               	.LVL89:
 1414               	.LBB215:
 1415               	.LBB216:
 614:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 1416               		.loc 2 614 0
 1417 0394 8093 F100 		sts 241,r24
 1418               	.LVL90:
 1419               	.LBE216:
 1420               	.LBE215:
 1421               	.LBB217:
 1422               	.LBB218:
 1423 0398 1092 F100 		sts 241,__zero_reg__
 1424               	.LVL91:
 1425               	.LBE218:
 1426               	.LBE217:
 1427               	.LBB219:
 1428               	.LBB220:
 683:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEDATX = (Word >> 8);
 1429               		.loc 2 683 0
 1430 039c 1092 F100 		sts 241,__zero_reg__
 1431               		.loc 2 684 0
 1432 03a0 1092 F100 		sts 241,__zero_reg__
 1433               	.LBE220:
 1434               	.LBE219:
 422:BootloaderDFU.c **** 
 1435               		.loc 1 422 0
 1436 03a4 8091 0000 		lds r24,DFU_State
 1437               	.LVL92:
 1438               	.LBB221:
 1439               	.LBB222:
 614:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 1440               		.loc 2 614 0
 1441 03a8 8093 F100 		sts 241,r24
 1442               	.LVL93:
 1443               	.LBE222:
 1444               	.LBE221:
 1445               	.LBB223:
 1446               	.LBB224:
 1447 03ac 1092 F100 		sts 241,__zero_reg__
 1448 03b0 00C0      		rjmp .L101
 1449               	.LVL94:
 1450               	.L64:
 1451               	.LBE224:
 1452               	.LBE223:
 1453               	.LBB225:
 1454               	.LBB226:
 494:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 1455               		.loc 2 494 0
 1456 03b2 8091 E800 		lds r24,232
 1457 03b6 877F      		andi r24,lo8(-9)
 1458 03b8 8093 E800 		sts 232,r24
 1459               	.LBE226:
 1460               	.LBE225:
 435:BootloaderDFU.c **** 
 1461               		.loc 1 435 0
 1462 03bc 1092 0000 		sts DFU_Status,__zero_reg__
 1463 03c0 00C0      		rjmp .L151
 1464               	.L63:
 1465               	.LBB227:
 1466               	.LBB228:
 494:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 1467               		.loc 2 494 0
 1468 03c2 8091 E800 		lds r24,232
 1469 03c6 877F      		andi r24,lo8(-9)
 1470 03c8 8093 E800 		sts 232,r24
 1471               	.LBE228:
 1472               	.LBE227:
 443:BootloaderDFU.c **** 
 1473               		.loc 1 443 0
 1474 03cc 8091 0000 		lds r24,DFU_State
 1475               	.LVL95:
 1476 03d0 00C0      		rjmp .L150
 1477               	.LVL96:
 1478               	.L151:
 1479               	/* epilogue start */
 458:BootloaderDFU.c **** 
 1480               		.loc 1 458 0
 1481 03d2 DF91      		pop r29
 1482 03d4 CF91      		pop r28
 1483 03d6 1F91      		pop r17
 1484 03d8 FF90      		pop r15
 1485 03da EF90      		pop r14
 1486 03dc DF90      		pop r13
 1487 03de CF90      		pop r12
 1488 03e0 BF90      		pop r11
 1489 03e2 AF90      		pop r10
 1490 03e4 9F90      		pop r9
 1491 03e6 8F90      		pop r8
 455:BootloaderDFU.c **** 			break;
 1492               		.loc 1 455 0
 1493 03e8 0C94 0000 		jmp Endpoint_ClearStatusStage
 1494               	.LVL97:
 1495               	.L57:
 1496               	/* epilogue start */
 458:BootloaderDFU.c **** 
 1497               		.loc 1 458 0
 1498 03ec DF91      		pop r29
 1499 03ee CF91      		pop r28
 1500 03f0 1F91      		pop r17
 1501 03f2 FF90      		pop r15
 1502 03f4 EF90      		pop r14
 1503 03f6 DF90      		pop r13
 1504 03f8 CF90      		pop r12
 1505 03fa BF90      		pop r11
 1506 03fc AF90      		pop r10
 1507 03fe 9F90      		pop r9
 1508 0400 8F90      		pop r8
 1509 0402 0895      		ret
 1510               		.cfi_endproc
 1511               	.LFE77:
 1513               	.global	EndAddr
 1514               		.section .bss
 1517               	EndAddr:
 1518 0000 0000      		.zero	2
 1519               	.global	StartAddr
 1522               	StartAddr:
 1523 0002 0000      		.zero	2
 1524               	.global	Flash64KBPage
 1527               	Flash64KBPage:
 1528 0004 00        		.zero	1
 1529               	.global	AppStartPtr
 1532               	AppStartPtr:
 1533 0005 0000      		.zero	2
 1534               		.comm	ResponseByte,1,1
 1535               		.comm	SentCommand,8,1
 1536               	.global	DFU_Status
 1539               	DFU_Status:
 1540 0007 00        		.zero	1
 1541               	.global	DFU_State
 1542               		.data
 1545               	DFU_State:
 1546 0000 02        		.byte	2
 1547               	.global	WaitForExit
 1548               		.section .bss
 1551               	WaitForExit:
 1552 0008 00        		.zero	1
 1553               	.global	RunBootloader
 1554               		.data
 1557               	RunBootloader:
 1558 0001 01        		.byte	1
 1559               	.global	IsSecure
 1560               		.section .bss
 1563               	IsSecure:
 1564 0009 00        		.zero	1
 1565               		.text
 1566               	.Letext0:
 1567               		.file 5 "/usr/lib/avr/include/stdint.h"
 1568               		.file 6 "../../LUFA/Drivers/USB/HighLevel/../LowLevel/../HighLevel/StdRequestType.h"
 1569               		.file 7 "BootloaderDFU.h"
 1570               		.file 8 "../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h"
 1571               		.file 9 "../../LUFA/Drivers/USB/HighLevel/USBTask.h"
 1572               		.file 10 "../../LUFA/Drivers/USB/HighLevel/../LowLevel/USBController.h"
 1573               		.file 11 "/usr/lib/avr/include/avr/eeprom.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 BootloaderDFU.c
     /tmp/ccay3HdD.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccay3HdD.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccay3HdD.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccay3HdD.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccay3HdD.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccay3HdD.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccay3HdD.s:13     .text.DiscardFillerBytes:0000000000000000 DiscardFillerBytes
     /tmp/ccay3HdD.s:81     .text.LoadStartEndAddresses:0000000000000000 LoadStartEndAddresses
                            *COM*:0000000000000008 SentCommand
     /tmp/ccay3HdD.s:1522   .bss:0000000000000002 StartAddr
     /tmp/ccay3HdD.s:1517   .bss:0000000000000000 EndAddr
     /tmp/ccay3HdD.s:110    .text.ProcessBootloaderCommand:0000000000000000 ProcessBootloaderCommand
     /tmp/ccay3HdD.s:1563   .bss:0000000000000009 IsSecure
     /tmp/ccay3HdD.s:1545   .data:0000000000000000 DFU_State
     /tmp/ccay3HdD.s:1539   .bss:0000000000000007 DFU_Status
     /tmp/ccay3HdD.s:1527   .bss:0000000000000004 Flash64KBPage
     /tmp/ccay3HdD.s:1551   .bss:0000000000000008 WaitForExit
     /tmp/ccay3HdD.s:1532   .bss:0000000000000005 AppStartPtr
     /tmp/ccay3HdD.s:1557   .data:0000000000000001 RunBootloader
                            *COM*:0000000000000001 ResponseByte
     /tmp/ccay3HdD.s:536    .text.SetupHardware:0000000000000000 SetupHardware
     /tmp/ccay3HdD.s:599    .text.ResetHardware:0000000000000000 ResetHardware
     /tmp/ccay3HdD.s:622    .text.startup.main:0000000000000000 main
     /tmp/ccay3HdD.s:668    .text.EVENT_USB_Device_UnhandledControlRequest:0000000000000000 EVENT_USB_Device_UnhandledControlRequest

UNDEFINED SYMBOLS
USB_Init
USB_ShutDown
USB_USBTask
USB_ControlRequest
eeprom_write_byte
eeprom_read_byte
Endpoint_ClearStatusStage
__do_copy_data
__do_clear_bss
